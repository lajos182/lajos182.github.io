[{"title":"No.5 Python语言基础--正则","date":"2020-04-30T10:02:38.000Z","path":"2020/04/30/No-5-Python语言基础-正则/","text":"5.1. 正则基础应用场景：特定规律字符串的查找、替换、切割等；邮箱格式、url等的验证；爬虫项���，提取特定的有效内容；很多应用的配置文件 使用原则：只要能够通过自负床等相关函数能够解决的，就不要使用正则；正则的执行效率比较低，会降低代码的可读性； 基本使用：正则式通过re模块提供支持的，相关函数包括match、search、findall、compile match：从头惊醒匹配，知道就立即返回正则结果对象，没有就返回None search：匹配全部内容，任意位置，只要找到，立即返回正则结果对象，没有返回None findall：匹配所有内容，返回匹配结构组成的列表，没有返回None compile：根据字符串生成正则表达式的对象，用于特定正则匹配，通过match、search、findall 5.2. 正则规则 单个字符： 1234567891011121314普通字符：就是一对一的完全匹配[]：中间的任意一个字符 [a-z]：表示a到z的任意字符 [0-9]：表示0到9的任意字符 [^abc]：除abc之外的字符. ：匹配'\\n'以外的任意字符\\d：所有的数字字符，等价于[0-9]\\D：所有的非数字字符，等价于[^0-9]\\w：所有的数字、字母、中文、下划线等 (就是字的意思)\\W：\\w之外的所有字符\\s：所有的空白字符，如：空格、\\t、\\n、\\r\\S：\\s之外的所有字符\\b：词边界，如：开头、结尾、标点、空格等\\B：非词边界 次数控制： 123456*：前面的字符可以是任意次+：前面的字符至少出现一次?：至多一次，0次或1次&#123;m&#125;：匹配固定的m次&#123;m,&#125;：至少m次&#123;m,n&#125;：m到n次 正则的匹配默认是贪婪的 贪婪：最大限度的匹配，正则的匹配默认是贪婪的 非贪婪：只要满足匹配条件，能少匹配就少匹配，通常使用’?’取消贪婪 123456789101112import re# c = re.compile(r'a.*?c')c = re.compile(r'a.+?c')s = c.search('abcjsdhfkdkc')if s: print('ok') print(s.group())&gt;&gt;&gt; okabc 边界限定 12^：以指定内容开头$：以指定内容结尾 分组匹配 12|：表示或，具有最低的优先级()：用于表示一个整体，可以确定优先级 1234567891011import rec = re.compile(r'(\\d+)([a-z]+)(\\d+)')s = c.search('sda123ksdak456sdk')if s: print('ok') print(s.group()) //所有匹配的字符(即匹配正则表达式整体结果) print(s.group(0)) //与group()相同 print(s.group(1)) //列出第一个括号匹配的字符 print(s.group(2)) //列出第二个括号匹配部分 print(s.group(3)) //列出第三个括号匹配部分 print(s.groups()) //返回所有括号匹配的字符，以tuple格式 1234567891011121314import re# 正则中的\\1:表示前面第一个小阔号匹配的结果# c = re.compile(r'&lt;([a-z]+)&gt;&lt;([a-z]+)&gt;\\w*&lt;/\\2&gt;&lt;/\\1&gt;')# c = re.compile(r'&lt;(?P&lt;hello&gt;[a-z]+)&gt;&lt;(?P&lt;world&gt;[a-z]+)&gt;\\w*&lt;/\\2&gt;&lt;/\\1&gt;')# 可以给指定的分组起个名字c = re.compile(r'&lt;(?P&lt;hello&gt;[a-z]+)&gt;&lt;(?P&lt;world&gt;[a-z]+)&gt;\\w*&lt;/(?P=world)&gt;&lt;/(?P=hello)&gt;')s = c.search('xxx&lt;div&gt;&lt;a&gt;百度一下&lt;/a&gt;&lt;/div&gt;yyy')if s: print('ok') print(s) print(s.group()) 转义字符 1234在匹配所有正则中有特殊含义的字符时，都需要转义。正则字符串需要被处理两次，python中处理，正则解析时处理一次。通常在写正则字符串时，前面都加一个'r'，表示原始字符，让所有的字符失去意义。在匹配有如：'\\'的字符时，前面再添加一个'\\'就可以了，如果没有添加'r'，通常要写好几个。 5.3. 正则高阶 匹配模式 正则可以对匹配的模式做出整体的修饰处理，如忽略大小写等。 12345678910111213141516import re# 忽略大小写# c = re.compile(r'hello', re.I)# 多行匹配# c = re.compile(r'^hello', re.M)# 作为单行处理 或 让 . 匹配 '\\n'c = re.compile(r'&lt;div&gt;.*?&lt;/div&gt;', re.S)string = ''''&lt;div&gt;\\nhello\\n&lt;/div&gt;'''s = c.search(string)if s: print('ok') print(s.group()) 字符串切割split 某些情况下，无法通过字符串函数进行切割，可以使用正则的方式处理，如：按照数字切割。可使用split切割，返回一个列表 123456789import rec = re.compile(r'\\d')string = '正则1其实也不难2但是学完发现自己写不出来3是这样吧'ret = c.split(string, maxsplit=2)print(ret)print(type(ret))&gt;&gt;&gt; ['正则', '其实也不难', '但是学完发现自己写不出来3是这样吧']&lt;class 'list'&gt; 字符串替换sub 简单的替换可以自己处理，要是按���正则规律进行替换就要使用专用的函数sub处理。 123456import rec = re.compile(r'\\d')string = 'sa1erfewr2fsdfs3dfsd'ret = c.sub('***', string)print(ret)","link":"","tags":[{"name":"Python","slug":"Python","permalink":"https://lajos182.github.io/tags/Python/"},{"name":"正则","slug":"正则","permalink":"https://lajos182.github.io/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"No.4 Python语言基础--模块使用","date":"2020-04-29T14:04:41.000Z","path":"2020/04/29/No-4-Python语言基础-模块使用/","text":"模块：模块就像一个工具包一样，里面有很多工具(函数、类)，使用时需要通过import导入。 分类： ①标准库：random、sys、os、time； ②第三方：已经写好的特定功能的模块，你可以直接使用pip命令安装； ③自定义：自己写的 12345import random # 导入import random as rdm # 导入并起别名from time import sleep # 指定导入from time import sleep as sp # 指定导入并起别名from random import * # 模糊导入 自定义模块：新建一个文件，不与其他模块同名，该文件名就是模块，导入方式于官方的相同。文件名(模块名)就是命名空间，不同命名空间下的标识符可以同名，当使用几个模块中相同的（函数）标识符时，可以通过命名空间或起别名解决。 测试模块：当一个模块作为主模块运行时，__ name __的值为&#39;__ main __&#39;，当被其他模块导入使用时，值为模块名。 12if __name__ &#x3D;&#x3D; &#39;__main__&#39;: print(&#39;测试代码&#39;) 包：多个模块放在同一目录下，目录下有一个__ init __.py文件，这个目录就是一个包。一个目录要想成为一个包，必须包含一个__ init __.py文件，即使该文件为空(可以简化导入书写) 修改pip源： Windows：进入用户的家目录(在windows文件管理器中,输入%APPDATA%)，在该目录下新建pip文件夹，并创建pip.ini，然后添加对应的镜像源； Linux：进入用户的加目录(cd ~)，然后创建.pip文件夹(mkdir .pip)并创建pip.conf(touch pip.conf)文件，然后对应的镜像源； 国内常用的pip镜像 1234567891011清华：https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple阿里云：http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;中国科技大学 https:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple&#x2F;华中理工大学：http:&#x2F;&#x2F;pypi.hustunique.com&#x2F;山东理工大学：http:&#x2F;&#x2F;pypi.sdutlinux.org&#x2F; 豆瓣：http:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F; 使用方法： 123[global]index-url &#x3D; http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;trusted-host &#x3D; mirrors.aliyun.com pip命令：安装软件包，自动会安装相关的依赖 12345678安装软件包：pip install 包名卸载软件包：pip uninstall 包名列表显示包：pip list查看指定包：pip show 包检测哪些包需要更新：pip list --outdated升级包：pip install --upgrade 包名输出已安装的包列表：pip freeze &gt; requirements.txtpip帮助：pip help","link":"","tags":[{"name":"Python","slug":"Python","permalink":"https://lajos182.github.io/tags/Python/"}]},{"title":"No.3 Python语言基础--函数及其常用函数的使用","date":"2020-04-28T10:35:40.000Z","path":"2020/04/28/No-3-Python语言基础-函数及其常用函数的使用/","text":"3.1. 函数的基本定义函数：具有特定功能的一段代码。 函数的优点： 解决代码的重复书写问题 可以将功能的实现者和使用者分开，提高开发效率 增加的代码的可移植性 函数参数： 形参：形式参数，函数定义处的参数 实参：实际参数，函数调用处的参数 必传参数：也叫位置参数，前面定义的函数中使用的都是必传参数，调用时的形式必须要与定义的一致。 默认参数：也称关键字参数，就是有默认值的参数，必须放在最后 可变长度参数：函数调用时传递必定义时的参数要多，多出来的参数会保存在args和kwargs中 *args与**kwargs的区别： 用*args和**kwargs只是为了方便并没有强制使用它们。 *args接受多余的位置参数，转化程元组tuple形式，**kwargs接受N个关键字参数，转换成字典dict形式 *的特殊用法： 123456789101112131415161718def show(a, b): print(a, b) l = [1, 2] # 略显啰嗦 # show(l[0], l[1]) # 精简方法 show(*l) def show2(a='aa', b='bb'): print(a, b) d = &#123;'a':'apple', 'b':'banana'&#125; # show2(a=d['a'], b=d['b']) # 上面方式的简单书写方法 show2(**d) 位置参数：调用参数时比较灵活，加不加关键字都可以，但python3.8引入新的语法控制这种灵活性，&#39;/&#39;之前的参数必须不加关键字，&#39;*&#39;之后的参数必须加关键字，其他参数依旧随意。 1234567891011121314151617181920212223242526272829303132# python3.8之前定义函数def center(txt, border='=', width=50): return f'&#123;txt&#125;'.center(width, border)# 调用结果：&gt;&gt;&gt;center('python')'=========================python========================'&gt;&gt;&gt;center('python', '*', 10)'**python**'&gt;&gt;&gt;center('python', border='*', width=10)'**python**'&gt;&gt;&gt;center(txt='python', border='*', width=10)'**python**'# python3.8新特性：def center(txt, /, border='=', *, width=50): return f'&#123;txt&#125;'.center(width, border)# 调用结果&gt;&gt;&gt; center(txt = '中心',border='$',width = 10)Traceback (most recent call last): File \"&lt;pyshell#68&gt;\", line 1, in &lt;module&gt; center(txt = '中心',border='$',width = 10)TypeError: center() got some positional-only arguments passed as keyword arguments: 'txt'&gt;&gt;&gt;center( '中心','$', 10)Traceback (most recent call last): File \"&lt;pyshell#69&gt;\", line 1, in &lt;module&gt; center( '中心','$', 10)TypeError: center() takes from 1 to 2 positional arguments but 3 were given&gt;&gt;&gt; center('中心',border='$',width = 10)'$$$$中心$$$$'&gt;&gt;&gt; center('中心','$',width = 10)'$$$$中心$$$$' 3.2. 变量作用域（LEGB）LEGB规则：local &gt; enclosed &gt; global &gt; bulit-in （1）块级作用域：Python不存在块级作用域，下民的代码可以正常运行。 1234if True: name = 'xiaoming'print(name) （2）局部作用域：定义在函数内部的变量叫局部变量，只能在函数内部使用。 123456def test(): a = 1test()# 此处会报错，提示变量未定义# print(a) （3）全局作用域：定义在函数外部的变量叫全局变量，哪里都可以使用(但是不能修改，除非使用global) 12345678a = 10def test(): # 加上这句代码，就可以在函数内部修改全局变量 global a a = 1test()print(a) （4）闭包函数外的函数中： 1234567891011def wai(): age = 20 def nei(): # 使用外层函数的局部变量，加上nonlocal姐可以修改外部函数的局部变量 nonlocal age age = 30 print(age) nei() print(age) wai() 3.3. 内置函数、模块函数及基本数据结构函数 3.4. 匿名函数匿名函数lambda：就是没有名字的函数，使用lambda关键字定义。 特点： 以lambda开头 后面跟上该匿名函数的参数，多个参数使用逗号隔开 最后一个参数的后面跟上冒号’:’ 冒号的后面跟上一个表达式，这个表达式就是返回值，不需要使用return 3.5. 递归函数递归函数： 函数内部调用函数本身的函数叫递归函数 特点： 代码简洁 可读性差(不易理解) 瞬间占用内存较大，没有终止条件会立即崩溃 有些领域禁止使用(安全领域：汽车电子) 只有在不得不使用的时候再使用(目录操作) 斐波那契数列(1,1,2,3,5,8,13,21,34,…) 123456def fibonacci(n): if n == 1 or n == 2: return 1 return fibonacci(n-2) + fibonacci(n-1)print(fibonacci(6)) 3.6. 闭包与装饰器闭包：外部函数中定义一个内部函数，内部函数中使用了外部函数的变量，外部函数将内部函数作为返回值返回。提高了代码的可重复使用性. 1234567def wai(n): def nei(): return n*n return neif1 = wai(3)print(f1()) 装饰器：本质就是一个函数，该函数接受一个函数作为参数，返回一个闭包，而且闭包中执行传递进来的函数，闭包中可以在函数执行的前后添加额外的功能。 装饰器的作用就是为已经存在的对象添加额外的功能。 12345678910def zhuangshiqi(func): def wrapper(*args, **kwargs): return func(*args, **kwargs) + 10 return wrapper@zhuangshiqidef pingfang(n): return n * nprint(pingfang(4)) 3.7. 迭代器与生成器 迭代器(Iterator)：可以使用for-in进行遍历，并且可以使用next依次获取元素的对象。 可以使用isinstance判断是否是迭代器。 1234from collections import Iteratorl = (i for i in range(10))print(isinstance(l, Iterator)) 生成器(generator)：为了解决内存突然变大的问题，Python引入了生成器。它是一种他叔的迭代器。 产生条件： 将列表生成式中的[]改为() 123456# 数据量特别大时，会造成内存占用突然增大# l2 = [i for i in range(10000)]# 生成器l2 = (i for i in range(2))# 使用next获取生成器中值，一次一个，遍历结束会报错StopIterationprint(next(l2)) 通常在函数中使用yield关键字 123def test(n): for i in range(1, n+1): yield i 特性 可以使用next获取数据，一次一个，结束时会报错 只能遍历一遍 可以转换为列表 可以使用for-in遍历 3.8. 高级函数 可迭代对象：可以使用for-in遍历的对象，我们都称之为可迭代对象。字符串、列表、元组、集合、字典等都不是迭代器，他们都是可迭代对象。 可以使用isinstance判断是否是可迭代对象： 123from collections import Iterableprint(isinstance(l, Iterable))print(isinstance(lt, Iterable)) 高级函数map：格式map(func, lt)，接受两个参数，一个函数和一个可迭代对象，返回一个生成器，将func依次作用于lt 12l = [1,2,3,4,5]m = map(lambda x:x*x, l) # 迭代器 高级函数filter：格式filter(funct, lt)，使用func依次作用于每个元素，处理结果为True保留下来。 123456l = [1,2,3,4,5]# 提取偶数f = filter(lambda x:x%2==0, l)print(list(f)) 高级函数reduce：格式reduce(func, lt), 接受两个参数，一个函数和一个可迭代对象，首先取两个元素，使用func处理，结果和第三个元素继续使用func处理，直到结束，返回处理的结果。 123456789from functools import reducel = [1,2,3,4,5]# 求和print(reduce(lambda x, y:x+y, l))# 转换为12345print(reduce(lambda x, y:x*10+y, l)) 高级函数sorted：格式sorted(func, lt), 内建函数，用于对可迭代快递的每个元素进行排序，生成新的对象。 123456789l = [ &#123;'name':'xiaowang', 'age':18,'height':150&#125;, &#123;'name':'xiaogang', 'age':20,'height':140&#125;, &#123;'name':'xiaohong', 'age':19,'height':145&#125;,]l2 = sorted(l, key=lambda x:x['age'], reverse=True)print(l2) 注意：sort也可用来排序，它是list的排序方法，用于对列表的成员进行排序，而且改变的是原列表。 3.9. 匿名、递归、闭包、高级函数总结 3.10.目录管理与文件操作相关模块函数 目录管理(os) 12345678910111213141516171819202122232425262728293031# system, 执行系统命令os.system('cls')# name, 获取操作系统名称，nt代表Windows, posix代表unixprint(os.name)# environ, 获取环境变量os.environ.get('path')os.environ.get(['path'])os.getenv('path')# getcwd, 获取当前工作目录os.getcwd()# mkdir, 创建目录，该方法创建中间目录会报错os.mkdir('hello')# makedirs, 创建目录，会创建中间目录os.makedirs('a/b/c')# rmdir, 删除目录，只能删除空目录os.rmdir('a')# rename, 修改文件名(可以是目录)os.rename('a', 'c')# stat, 查看文件信息os.stat('123.py')# listdir, 列出直接子文件os.listdir('c') path函数 123456789101112131415161718192021222324252627from os import path# 提取文件后缀（切割文件名与后缀）name, ext = path.splitext('789.py')print(name, ext)# 提取目录名（最后一个目录分隔符的前面内容）print(path.dirname('123/456/789.py'))# 提取文件名(包括后缀)print(path.basename('123/456/789.py'))# 切割文件名和目录print(path.split('123/456/789.py'))# 判断文件是否存在（可以是目录）print(path.exists('123.py'))# 判断是否是目录文件print(path.isdir('c'))# 判断是否是普通文件print(path.isfile('123.py'))# 获取普通文件大小print(path.getsize('01-os.py'))# 不可以获取目录大小，始终是0print(path.getsize('c')) 文件管理 打开文件（open）：fp = open(&#39;00-test.txt&#39;, &#39;r&#39;) 1234567891011121314151617181920# 参数1：文件路径名；参数2：打开方式；参数3：编码格式，一般不用指定，系统会自动识别处理# 打开方式：r：只读方式，文件不存在会报错w：只写方式，文件不存在创建文件，文件存在清空内容a：追加方式，文件不存在则创建，文件存在直接打开(不会清空内容)，只能向最后追加内容r+：在r方式下添加写的功能w+：在w方式下添加读的功能a+：在a方式下添加读的功能在上面的模式上添加b，表示二进制方式打开：rb、wb、ab、rb+、wb+、ab+1.文件的读写数据全部是bytes类型，没有添加b的方式全部是str类型# 编码方式ascii：美国信息交换标准代码ansi：扩展的asciigb2312：中国的ansigbk：扩展的gb2312unicode：是一套理论，实现方式不限utf-8：可变长度的unicode实现，对中文的支持比较友好 关闭文件（close）：fp.close() 文件读写 12345678910111213141516# 读取指定长度内容# ret = fp.read(3)# 写入内容fp.write('hello')# 读取一行，包括换行符print(fp.readline())# 读取所有行，返回一个列表print(fp.readlines())# 是否可读print(fp.readable())# 是否可写print(fp.writable()) read、readline和readlines的区别，如何读取大文件 read()方法：读取整个文件，将文件内容放到一个字符串变量中，如果需要对文件按行进行处理，则不可用该方法。如果文件大于可用内存(好几个G的)，不可能使用这种处理，系统会报错：MemoryError readline()方法： 读取下一行，每只读取文件的一行，通常也是读取到的一行内容放到一个字符串变量中，返回str类型。内存不够时使用，一般不太用。 readlines()方法：读取整个文件所有行，保存在一个列表(list)变量中，每行作为一个元素，但读取大文件会比较占内存。 大文件读取数据：处理大文件是很容易想到的就是将大文件分割成若干小文件处理，处理完每个小文件后释放该部分内存（分块读取）。这里用了iter &amp; yield 分块读取（yield）：将大文件分割成若干小文件处理，处理完每个小文件后释放该部分内存 1234567891011121314151617# 分块读取def read_chunk(file_name, trunk_size): fp = open(file_name, 'rb') # 创建文件对象，也是一个可迭代对象 # while True: # content = fp.read(trunk_size) # if not content: # break # yield content content = fp.read(trunk_size) while content: content = fp.read(trunk_size) yield content if __name__ == '__main__': file_name = r'F:\\AngularJS学习资料\\第一章 AngularJS教程.md' for i in read_chunk(file_name, 50): print(i) 使用with（操作可迭代对象）：对可迭代对象 fp，进行迭代遍历：for line in fp，会自动地使用缓冲IO（buffered IO）以及内存管理，而不必担心任何大文件的问题。 123with open(r'F:\\AngularJS学习资料\\第一章 AngularJS教程.md', 'rb') as fp: for line in fp: print(line) 文件指针 12345678# 返回文件指针的操作位置print(fp.tell())# 设置偏移# 参数1：偏移量# 参数2：参考位置，0：开头，1：当前，2：末尾# 定位到末尾fp.seek(0, 2) 带b的方式seek没有异常；不带b的时候，相对于当前位置无法偏移，相对于末尾只能偏移0 文件删除 12import osos.remove('02-test.py') 文件高级操作shutil: copyfileobj(fsrc, fdst, length=16*1024)：将fsrc文件内容复制至fdst文件，length为fsrc每次读取的长度，用做缓冲区大小 1234import shutilfp1 = open('file.txt', 'r')fp2 = open('file_copy.txt', 'a+')shutil.copyfileobj(fp1, fp2, length=1024) copyfile(src, dst)：将src文件内容复制至dst文件，若dst文件不存在，将会生成一个dst文件；若存在将会被覆盖 12import shutilshutil.copyfile(\"file.txt\",\"file_copy.txt\") copymode(src, dst, follow_symlinks=True)：将src文件权限复制至dst文件，文件内容，所有者和组不受影响。dst路径必须是真实的路径，并且文件必须存在，否则将会报文件找不到错误。follow_symlinks为Python3新增参数，设置为False时，src, dst皆为软连接，可以复制软连接权限，如果设置为True，则当成普通文件复制权限。默认为True。 12import shutilshutil.copymode(\"file.txt\",\"file_copy.txt\") copystat(src, dst, follow_symlinks=True)：将权限，上次访问时间，上次修改时间以及src的标志复制到dst。文件内容，所有者和组不受影响。follow_symlinks设置为False时，src, dst皆为软连接，可以复制软连接权限、上次访问时间，上次修改时间以及src的标志，如果设置为True，则当成普通文件复制权限。默认为True。 12import shutilshutil.copystat(\"file.txt\",\"file_copy.txt\") copy(src, dst, follow_symlinks=True)： 将文件src复制至dst。dst可以是个目录，会在该目录下创建与src同名的文件，若该目录下存在同名文件，将会报错提示已经存在同名文件。权限会被一并复制。本质是先后调用了copyfile与copymode而已。follow_symlinks和上面作用相同。 1234improt shutil,osshutil.copy(\"file.txt\",\"file_copy.txt\")# 或者shutil.copy(\"file.txt\",os.path.join(os.getcwd(),\"copy\")) copy2(src, dst, follow_symlinks=True)：将文件src复制至dst。dst可以是个目录，会在该目录下创建与src同名的文件，若该目录下存在同名文件，将会报错提示已经存在同名文件。权限、上次访问时间、上次修改时间和src的标志会一并复制至dst。本质是先后调用了copyfile与copystat方法而已。follow_symlinks和上面作用相同。 1234improt shutil,osshutil.copy2(\"file.txt\",\"file_copy.txt\")# 或者shutil.copy2(\"file.txt\",os.path.join(os.getcwd(),\"copy\")) ignore_patterns(*patterns)：忽略模式，用于配合copytree()方法，传递文件将会被忽略，不会被拷贝。patterns是文件名称、元组。 **copytree(src, dst, symlinks=False, ignore=None,copy_function=copy2, ignore_dangling_symlinks=False`)`**：拷贝文档树，将`src`文件夹里的所有内容拷贝至`dst`文件夹，文件夹不存在会自动创建。`symlinks`代表是否复制软连接，`True`复制软连接，`False`不复制，软连接会被当成文件复制过来，默认`False`。`ignore`为忽略模式，可传入`ignore_patterns()`。`copy_function`为拷贝文件的方式，可传入一个可执行的处理函数，默认为`copy2`，`ignore_dangling_symlinks`设置为`False`，拷贝指向文件已删除的软连接时，将会报错，如果想消除这个异常，可以设置此值为True，默认为`False`。123456import shutil,osfolder1 = os.path.join(os.getcwd(),\"aaa\")# bbb与ccc文件夹都可以不存在,会自动创建folder2 = os.path.join(os.getcwd(),\"bbb\",\"ccc\")# 将\"abc.txt\",\"bcd.txt\"忽略，不复制shutil.copytree(folder1,folder2,ignore=shutil.ignore_patterns(\"abc.txt\",\"bcd.txt\") rmtree(path, ignore_errors=False, onerror=None)：移除文档树，将文件夹目录删除。ignore_errors代表是否忽略错误，默认False，onerror定义错误处理函数，需传递一个可执行的处理函数，该处理函数接收三个参数：函数、路径和excinfo 123import shutil,osfolder1 = os.path.join(os.getcwd(),\"aaa\")shutil.rmtree(folder1) move(src, dst, copy_function=copy2)：将src移动至dst目录下。若dst目录不存在，则效果等同于src改名为dst。若dst目录存在，将会把src文件夹的所有内容移动至该目录下面。copy_function为拷贝文件的方式，可传入一个可执行的处理函数，默认为copy2。 12345678910111213import shutil,os# 示例一，将src文件夹移动至dst文件夹下面，如果bbb文件夹不存在，则变成了重命名操作folder1 = os.path.join(os.getcwd(),\"aaa\")folder2 = os.path.join(os.getcwd(),\"bbb\")shutil.move(folder1, folder2)# 示例二，将src文件移动至dst文件夹下面，如果bbb文件夹不存在，则变成了重命名操作file1 = os.path.join(os.getcwd(),\"aaa.txt\")folder2 = os.path.join(os.getcwd(),\"bbb\")shutil.move(file1, folder2)# 示例三，将src文件重命名为dst文件(dst文件存在，将会覆盖)file1 = os.path.join(os.getcwd(),\"aaa.txt\")file2 = os.path.join(os.getcwd(),\"bbb.txt\")shutil.move(file1, file2) disk_usage(path)：获取当前目录所在硬盘使用情况。path表示文件夹或文件路径，windows中必须是文件夹路径，linux中可以是文件路径和文件夹路径。 1234import shutil.ospath = os.path.join(os.getcwd(),\"aaa\")info = shutil.disk_usage(path)print(info) # usage(total=95089164288, used=7953104896, free=87136059392) chown(path, user=None, group=None)：修改路径指向的文件或文件夹的所有者或分组。 123import shutil,ospath = os.path.join(os.getcwd(),\"file.txt\")shutil.chown(path, user=\"root\", group=\"root\") which(cmd, mode=os.F_OK | os.X_OK, path=None)： 获取给定的cmd命令的可执行文件的路径。 12import shutilprint(shutil.which('pip')) # D:\\Python\\Python36\\Scripts\\pip.EXE make_archive(base_name, format, root_dir, …)：生成压缩文件。base_name指压缩文件的文件名，不允许有扩展名(因为会根据压缩格式生成相应的扩展名)，format表示压缩格式，root_dir表示将指定文件夹进行压缩。 123456import shutil,osbase_name = os.path.join(os.getcwd(),\"aaa\")format = \"zip\"root_dir = os.path.join(os.getcwd(),\"aaa\")# 将会root_dir文件夹下的内容进行压缩，生成一个aaa.zip文件shutil.make_archive(base_name, format, root_dir) get_archive_formats()：获取支持的压缩文件格式。目前支持的有：tar、zip、gztar、bztar。在Python3还多支持一种格式xztar。 unpack_archive(filename, extract_dir=None, format=None)：解压操作，extract_dir解压至的文件夹路径，文件夹可以不存在，会自动生成。format解压格式，默认为None，会根据扩展名自动选择解压格式。 1234import shutil,oszip_path = os.path.join(os.getcwd(),\"aaa.zip\")extract_dir = os.path.join(os.getcwd(),\"aaa\")shutil.unpack_archive(zip_path, extract_dir) get_unpack_formats()：获取支持的解压文件格式。目前支持的有：tar、zip、gztar、bztar和xztar。 经典练习 实现一个拷贝文件的功能，提醒：要考虑超大文件问题，如:依次读取1024字节，循环读取 123456789101112131415161718192021import osdef copy_file(source, target): if not os.path.exists(source): print('源文件不存在！') return if os.path.isdir(source): print('源文件是目录文件，无法拷贝！') return if os.path.abspath(source) == os.path.abspath(target): print('复制的地址与源文件相同，无法进行复制！') return if os.path.isdir(target): target = os.path.join(target, os.path.basename(source)) source_fp = open(source, 'rb') target_fp = open(target, 'wb') content = source_fp.read(1024) while content: target_fp.write(content) content = source_fp.read(1024) source_fp.close() target_fp.close() 递归拷贝一个文件夹 1234567891011121314151617181920212223def copy_dir(source, target): if not os.path.exists(source): print('原文件不存在！') return if os.path.isfile(target): print('源文件不是目录文件！') if os.path.isfile(target): print('目标地址不是目录，无法进行拷贝') return if os.path.abspath(source) == os.path.abspath(target): print('复制的地址与源文件相同，无法进行复制') return if not os.path.exists(target): os.makedirs(target) source_list = os.listdir(source) for item in source_list: source_name = os.path.join(source, item) target_name = os.path.join(target, item) if os.path.isfile(source_name): copy_file(source_name, target_name) # 拷贝单个文件 else: copy_dir(source_name, target_name) # 递归拷贝 copy_dir('a', 'b') 递归删除一个文件夹(或文件) 12345678910111213141516import osdef delete_dir(source): if not os.path.exists(source): print('要删除的文件不存在！') return if os.path.isfile(source): os.remove(source) source_list = os.listdir(source) for item in source_list: source_path = os.path.join(source, item) if os.path.isfile(source_path): os.remove(source_path) else: delete_dir(source_path) os.rmdir(source)delete_dir('../ccc') 递归统计一个文件夹的大小 12345678910111213141516171819import osdef get_size(source): size = 0 if not os.path.exists(source): print('当前文件(夹)不存在！') return if os.path.isfile(source): size += os.path.getsize(source) return size source_list = os.listdir(source) for item in source_list: source_path = os.path.join(source, os.path.basename(item)) if os.path.isfile(source_path): size += os.path.getsize(source_path) else: size += get_size(source_path) return sizeprint(get_size('a_a.py')) 移动文件夹 12345678910111213141516171819202122232425262728def move_dir(source, target): if not os.path.exists(source): print('不存在该文件，无法移动') return if os.path.abspath(source) == os.path.abspath(target): print('源文件地址与指定的地址相同，无法进行移动') return if os.path.isfile(source): source_fp = open(source, 'r') target_fp = open(target, 'w') content = source_fp.read(1024) while content: target_fp.write(content) content = source_fp.read(1024) source_fp.close() target_fp.close() os.remove(source) else: if not os.path.exists(target): os.makedirs(target) source_list = os.listdir(source) for item in source_list: source_item = os.path.join(source, item) target_item = os.path.join(target, item) move_dir(source_item, target_item) os.rmdir(source)move_dir('a', 'c') 目录整理 1234567891011121314151617181920212223242526# 将目录按后缀进行分类，后缀相同的放到后缀字母大写的文件中，没有后缀的放置在'OTHERS'中，文件夹放在'DIRS'中import os, shutildef clean_dir(source): if os.path.isfile(source) or not os.path.exists(source): print('当前目录无法整理，请查询你要整理的目录！') return source_list = os.listdir(source) for item in source_list: source_path = os.path.join(source, item) if os.path.isfile(source_path): suffix = source_path.rsplit('.', 1) if len(suffix) == 2: SUFFIX = os.path.join(source, suffix[1].upper()) if not SUFFIX: os.mkdir(SUFFIX) shutil.move(source_path, SUFFIX) else: OTHERS = os.path.join(source, 'OTHERS') if not OTHERS: os.mkdir(OTHERS) shutil.move(source_path, OTHERS) else: DIRS = os.path.join(source, 'DIR') if not DIRS: os.mkdir(DIRS) shutil.move(source_path, DIRS) 3.11. 时间、日期和日历相关模块函数 time模块： sleep：休眠指定的秒数(可以是小数) localtime： 将一个时间戳转换为time.struct_time类型的对象(类似于元组) 123import timeprint(time.localtime())&gt;&gt;&gt; time.struct_time(tm_year=2019, tm_mon=4, tm_mday=28, tm_hour=9, tm_min=25, tm_sec=34, tm_wday=6, tm_yday=118, tm_isdst=0) 年、月、日、时、分、秒、星期(0~6)、今年的第几天、夏令时 mktime：根据元组形式的时间生成一���时间戳 123import timeprint(time.mktime((2019, 4, 28, 9, 25, 34, 6, 118, 0))) # 注意一定是一个元组&gt;&gt;&gt; 1556414734.0 strftime：将一个元组形式的时间格式化为字符串，不传时间默认转换当前时间 123time.strftime('%Y-%m-%d %H:%M:%S %w %W', local_time)&gt;&gt;&gt; '2019-04-28 09:34:53 0 16'# 注意与datetime.datetime.strftime的区别，datetime.datetime.strftime(time, '%Y-%m-%d %H:%M:%S:%f') gmtime：将一个时间戳转换为元组形式，不传默认转换当前时间 12print(time.gmtime())# time.struct_time(tm_year=2019, tm_mon=4, tm_mday=28, tm_hour=1, tm_min=50, tm_sec=27, tm_wday=6, tm_yday=118, tm_isdst=0) asctime：将一个元组形式的时间转换为标准格式字符串，不传参数转换当前时间 12print(time.asctime())# 'Sun Apr 28 09:49:13 2019' timezone：0时区减去当前时区的秒数 1print(time.timezone) # -28800 datetime模块： date()：获取一定格式的时间，print(date(2019, 5. 3)), # 2019-05-03 d = date.today()：获取今天的时间 d.fromtimestamp()：将时间戳转化为日期， print(d.fromtimestamp(time.time())) d.isoformat()：标准格式字符 d.isocalendar()：日历显示形式，如(年，第几周， 星期几) d.isoweekday()：获取星期(1~7) d.weekday(): 获取星期(0~6) d.strftime()：格式化，print(d.strftime(&#39;%y-%m-%d&#39;)) d.timetuple()：转化为元组 time()：获取一定格式的时间，tm = time() tm.hour：获取小时 tm.minute：获取分钟 tm.second：获取秒数 tm.strftime()：时间格式化，print(tm.strftime(&#39;%H:%M:%S&#39;)) datetime： datetime.now()：获取本地时间 datetime.utcnow()：获取UTC时间(格林尼治时间) datetime.fromtimestamp()：将一个时间戳转化为datetime datetime.fromtimestamp.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)：格式化显示 timedelta(): delta = timedelta()：获取时间差，print(timedelta(days=2, hours=2, seconds=56)) delta.days：获取天数 delta.seconds：获取天数外的秒数 delta.total_seconds()：获取总秒数 calendar模块： calendar：获取某一年的日历 12# 获取某一年的日历, 参数：年份， w =列宽， l= 行宽，m = 控制每行打印月份数， c=每个月份之间的间距c = calendar.calendar(2018, w=3, l=2, m=2, c=10) month：获取指定年指定月份的日历： 12# 获取指定年指定月的日历m = calendar.month(2018, 3) isleap：判断是否是闰年 1print(calendar.isleap(2062)) leapdays：判断两个年份之间的瑞年的个数([起始，结束)) 1print(calendar.leapdays(1992, 2018)) 3.12. 短信邮件相关模块函数 hashlib：用来进行hash或者md5加密，而且这种加密是不可逆的，所以这种算法又被称为摘要算法。其支持Openssl库提供的所有算法，包括md5、sha1、sha224、sha256、sha512等。 md5()：创建一个md5加密模式的hash对象，可以指定需要加密的字符串 update()：设置加密字符串，创建md5对象就不必指定了，不能两个地方都指定 hexdigest()：获取加密后的摘要(32位) 12345678import hashlibmd = hashlib.md5() md.update('123456'.encode('utf-8'))print(md.hexdigest()) # e10adc3949ba59abbe56e057f20f883emd = hashlib.md5('123456'.encode('utf-8')) # 如果添加参数，就相当于多进一层加密md.update('123456'.encode('utf-8'))print(md.hexdigest()) # ea48576f30be1669971699c09ad05c94 urlib：提供了一系列用于操作URL的功能，是Python的标准库 request：发送http请求 urlopen()：访问目标网址，结果是一个http.client.HTTPResponse对象，默认访问方法是GET，当在该方法中传入data参数时，则会发起POST请求。 1urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None) 123456789from urllib import requestrep = request.urlopen('http://www.baidu.com')print(rep.read().decode('utf-8'))# urlopen返回对象提供方法： # read() , readline() ,readlines() , fileno() , close() ：对HTTPResponse类型数据进行操作。 # info()：返回HTTPMessage对象，表示远程服务器返回的头信息。 # getcode()：返回Http状态码。 geturl()：返回请求的url。 1234from urllib import request# 设置timeout，如果请求时间超出，那么就会抛出异常resp = request.urlopen('http://httpbin.org', data='word=hello'.encode('utf-8'), timeout=10)print(resp.read().decode('utf-8')) Reuqest()：传入的request对象，而不是一个url 12345678urllib.request.Request(url, data=None, headers=&#123;&#125;, origin_req_host=None, unverifiable=False, method=None)url--访问的地址。data--此参数为可选字段，其中传递的参数需要转为bytes，如果是字典我们只需要通过urlencode转换即可。headers--http相应headers传递的信息，构造方法：headers参数传递，通过调用Request对象的add_header()方法来添加请求头。origin_req_host--指的是请求方的host名称或者IP地址。unverifiable--用来表明这个请求是否是无法验证的，默认是False。意思就是说用户没有足够权限来选择接收这个请求的结果。如果没有权限，这时unverifiable的值就是True 。method--用来指示请求使用的方法，比如GET，POST，PUT等 123456789101112131415161718192021# 使用urllib模拟微博登录from urllib import requestfrom urllib.parse import urlencodeprint('Login to weibo.cn...')email = input('Email: ')passwd = input('Password: ')login_data = urlencode([ ('username', email), ('password', passwd), ('entry', 'mweibo'), ('client_id', ''), ('savestate', '1'), ('ec', ''), ('pagerefer', 'https://passport.weibo.cn/signin/welcome?entry=mweibo&amp;r=http%3A%2F%2Fm.weibo.cn%2F')])req = request.Request('https://passport.weibo.cn/sso/login')req.add_header('Origin', 'https://passport.weibo.cn')req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')req.add_header('Referer', 'https://passport.weibo.cn/signin/login?entry=mweibo&amp;res=wel&amp;wm=3349&amp;r=http%3A%2F%2Fm.weibo.cn%2F')rep = request.urlopen(req, data=login_data.encode('utf-8'))print(rep.read().decode('utf-8')) 添加Cookie：使用request.build_opener方法来进行构造opener 12345678910111213from http import cookiejarfrom urllib import requesturl = 'http://httpbin.org/cookies'# 创建一个cookiejar对象cookie = cookiejar.CookieJar()# 使用HTTPCookieProcessor创建cookie处理器cookies = request.HTTPCookieProcessor(cookie)# 并以它为参数创建Opener对象opener = request.build_opener(cookies)# 使用这个opener来发起请求resp = opener.open(url)print(resp.read().decode()) 或者也可以把这个生成的opener使用install_opener方法来设置为全局的。则之后使用urlopen方法发起请求时，都会带上这个cookie。 123# 将这个opener设置为全局的openerrequest.install_opener(opener)resp = request.urlopen(url) 设置Proxy代理：使用爬虫来爬取数据的时候，常常需要使用代理来隐藏我们的真实IP。 12345678910from urllib import requesturl = 'http://httpbin.org/ip'proxy = &#123;'http':'50.233.137.33:80','https':'50.233.137.33:80'&#125;# 创建代理处理器proxies = requet.ProxyHandler(proxy)# 创建opener对象opener = request.build_opener(proxies)resp = opener.open(url)print(resp.read().decode()) error：处理请求过程中出现的异常 用 try-except来捕捉异常,主要的错误方式就两种URLError（错误信息）和HTTPError(错误编码)。 12345678from urllib import request, errortry: data= request.urlopen(url) print(data.read().decode('utf-8'))except error.HTTPError as e: # 错误编码 print(e.code)except error.URLError as e: # 错误信息 print(e.reason) parse：解析url urlencode()将字典转化为key1=value1&amp;key2=value2格式 123456from urllib.parse import urlencodedata = &#123; 'name': 'lajos', 'age': 18&#125;print(urlencode(data)) # name=lajos&amp;age=18 urlparse()：解析url中的所有参数，得到的是urllib.parse.ParseResult对象 parse_qs()：将url请求参数转化为字典 123456from urllib.parse import parse_qs, urlparseurl = 'http://www.baidu.com/abc/def?name=lajos&amp;age=18'url_parse = urlparse(url)print(url_parse) # ParseResult(scheme='http', netloc='www.baidu.com', path='/abc/def', params='', query='name=lajos&amp;age=18', fragment='')print(url_parse.query) # name=lajos&amp;age=18print(parse_qs(url_parse.query)) # &#123;'name': ['lajos'], 'age': ['18']&#125; robotparser：解析robots.txt文件 http.client：网络请求 12345678910import http.client# 创建连接(相当于浏览器)connect = http.client.HTTPConnection('www.baidu.com')# 发送请求(GET/POST)connect.request(method='GET', url='http://www.baidu.com')# 获取响应resp = connect.getresponse()# 打印响应内容，读取并解码print(resp.read().decode('utf-8')) 邮件发送smtplib：提供了一种很方便的途径发送电子邮件。它对smtp协议进行了简单的封装。 SMTP():（Simple Mail Transfer Protocol)即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。 12345import smtplibsmtp_obj = smtplib.SMTP([host, [, port [, local_hostname]]])# host: SMTP 服务器主机。 你可以指定主机的ip地址或者域名如: runoob.com，这个是可选参数。# port: 如果你提供了host参数, 你需要指定SMTP服务使用的端口号，一般情况下SMTP端口号为25。# local_hostname: 如果 SMTP 在你的本机上，你只需要指定服务器地址为 localhost 即可。 SMTP.sendmail()：发送邮件 1234SMTP.sendmail(from_addr, to_addrs, msg[, mail_options, rcpt_options])# from_addr: 邮件发送者地址。# to_addrs: 字符串列表，邮件发送地址。# msg: 发送消息，格式是字符串，一般包含标题，发信人，收件人，邮件内容，附件等 12345678910111213141516171819202122232425262728293031323334353637383940import smtplibfrom email.mime.text import MIMETextfrom email.header import Headerfrom email.mime.multipart import MIMEMultipartimport os# 邮箱服务器mail_server = 'smtp.qq.com'# 用户名mail_user = '13249732498@qq.com'# 密码或授权码，为了不公开可以通过环境变量的方式获取mail_password = os.environ.get('MAIL_PASSWORD') or '123456'# 邮件消息def send_mail(to_addrs): try: message = '你好，欢迎注册xxx平台，激活请点击右边链接 &lt;a href=\"http://www.baidu.com\"&gt;点击激活&lt;/a&gt;' # 将邮件字符串消息转换邮件格式，若内容是HTML需要指定第二个参数为'html' message = MIMEText(message, 'html') # 设置主题 message['Subject'] = Header('账户激活') # 设置显示的发件人 message['From'] = Header(mail_user) # 设置显示的收件人，可以给多个人发邮件 message['To'] = Header(to_addrs) # 创建邮件对象 mail = smtplib.SMTP(mail_server, 25) # 登录服务器 mail.login(mail_user, mail_password) # 发送邮件 mail.sendmail(mail_user, to_addrs, message.as_string()) mail.quit() except Exception: ret = False return retret = send_mail('1823423231@qq.com, 23423412@163.com')if ret: print('邮件发送成功！')else: print('邮件发送失败！') 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import smtplibfrom email.mime.text import MIMETextfrom email.header import Headerfrom email.mime.multipart import MIMEMultipartimport os# 邮箱服务器mail_server = 'smtp.qq.com'# 用户名mail_user = '1287174078@qq.com'# 密码或授权码，为了不公开可以通过环境变量的方式获取mail_password = os.environ.get('MAIL_PASSWORD') or 'qwewqrewr'# 邮件消息def send_mail(to_addrs): try: message = MIMEMultipart() # 设置主题 message['Subject'] = Header('账户激活') # 设置显示的发送人 message['From'] = Header(mail_user) # 设置显示的收件人，可以给多个人发邮件 message['To'] = Header(to_addrs) body = '这是Python邮件发送测试.....' # 邮件正文内容 message.attach(MIMEText(body, 'plain')) # 构造附件1，传送当前目录下的 test.txt 文件 att1 = MIMEText(open('test1.txt', 'rb').read(), 'base64', 'utf-8') att1['Content-Type'] = 'application/octet-stream' att1[\"Content-Disposition\"] = 'attachment; filename=\"test.txt\"' message.attach(att1) # 构造附件2，传送当前目录下的 runoob.txt 文件 att2 = MIMEText(open('yunda.py', 'rb').read(), 'base64', 'utf-8') att2[\"Content-Type\"] = 'application/octet-stream' att2[\"Content-Disposition\"] = 'attachment; filename=\"yunda.py\"' message.attach(att2) # 创建邮件对象 mail = smtplib.SMTP(mail_server, 25) # 登录服务器 mail.login(mail_user, mail_password) # 发送邮件 mail.sendmail(mail_user, to_addrs, message.as_string()) mail.quit() except Exception: ret = False return retret = send_mail('1825871201@qq.com')if ret: print('邮件发送成功！')else: print('邮件发送失败！') 短信发送：常使用短信发送平台，如阿里、云之讯、秒滴 该案例使用阿里短信平台对接，需要的参数如下： 安装Python环境的依赖包：pip install aliyun-python-sdk-core，使用于python2.6.5及其更高版本 accessKeyId：主账号AccessKey的IDaccessSecret：主账号的密钥SignName：短信签名名称PhoneNumbers：要发送的电话号码TemplateCode：短信模板ID，例如&#39;SMS_153055065&#39;TemplateParam：短信模板变量对应的实际值，JSON格式，如&#39;{&quot;code&quot;: &quot;1234&quot;}&#39; 1234567891011121314151617181920# 将对应的参数替换即可进行调用阿里云短信服务平台from aliyunsdkcore.client import AcsClientfrom aliyunsdkcore.request import CommonRequestclient = AcsClient('&lt;accessKeyId&gt;', '&lt;accessSecret&gt;', 'default')request = CommonRequest()request.set_accept_format('json')request.set_domain('dysmsapi.aliyuncs.com')request.set_method('POST')request.set_protocol_type('https') # https | httprequest.set_version('2017-05-25')request.set_action_name('SendSms')request.add_query_param('SignName', 'lajos')request.add_query_param('PhoneNumbers', '15299013421')request.add_query_param('TemplateCode', 'SMS_135695051')request.add_query_param('TemplateParam', '&#123;\"code\": \"1123\"&#125;')response = client.do_action(request)print(str(response, encoding='utf-8'))","link":"","tags":[{"name":"Python","slug":"Python","permalink":"https://lajos182.github.io/tags/Python/"},{"name":"函数","slug":"函数","permalink":"https://lajos182.github.io/tags/%E5%87%BD%E6%95%B0/"}]},{"title":"No.2 Python语言基础--变量、数据类型及运算符","date":"2020-04-27T07:09:51.000Z","path":"2020/04/27/No-2-Python语言基础-变量、数据类型及运算符/","text":"2.1. 标识符、变量与常量标识符：开发人员在程序中自定义的一些符合和名称，其实就是一串字符串，如变量名、函数名等 Python标识符规则：只能由数字、字符和下划线组成，开头不能是数字，不能是关键字，大小写敏感且见名知义，要遵循小驼峰原则。 123import keywordprint(keyword.kwlist) # 关键字列表&gt;&gt;&gt;['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 变量：在程序运行过程中，其值可以改变的量。 变量命名原则：尽量做到见名知意、尽量使用英文、推荐使用全小写加下划线的方式，如user_name 常量：程序运行期间不会改变的数据，如a = 1。在python中没有常量，通常使用大写字母加下划线的方式模拟，如：USER_NAME = &#39;xiaoming&#39; 代码注释：单行注释（# 注释内容）、多行注释（&#39;&#39;&#39;注释&#39;&#39;&#39;, &quot;&quot;&quot;注释&quot;&quot;&quot;） 2.2. 数据类型数据类型是为了处理不同的运算而存在，python中的数据类型有：整型(int)、浮点(float)、字符串(str)、列表(list)、元组(tuple)、字典(dict)、集合(set)、空(NoneType) 2.2.1. 字符串格式化在 Python 3.6 之前，字符串格式化方法主要有两种：%格式化 和 str.format()，Python3.6提供了一种新的字符串格式化方法：f-string (1)%-格式化从 Python 刚开始时就存在了，堪称「一届元老」，但是 Python 官方文档中并不推荐这种格式化方式： 这里描述的格式化操作容易表现出各种问题，导致许多常见错误（例如无法正确显示元组和字典）。 使用较新的格式化字符串文字或 str.format() 可以有助于避免这些错误。这些替代方案还提供了更强大，灵活和可扩展的格式化文本方法。 1234&gt;&gt;&gt; name = 'lajos'&gt;&gt;&gt; age = 18&gt;&gt;&gt; 'hello, %s, your age is %s ?' %(name, age)'hello, lajos, your age is 18?' (2)str.formar()从Python2.6开始引入，它使用普通函数调用语法，并且可以通过 __format__() 方法为对象进行扩展。 12&gt;&gt;&gt; \"hello, &#123;&#125;. you are &#123;&#125;?\".format(name,age)'hello, hoxis. you are 18?' 12&gt;&gt;&gt; \"hello, &#123;1&#125;. you are &#123;0&#125;?\".format(age,name)'hello, hoxis. you are 18?' 12&gt;&gt;&gt; \"hello, &#123;name&#125;. you are &#123;age1&#125;?\".format(age1=age,name=name)'hello, hoxis. you are 18?' 123&gt;&gt;&gt; person = &#123;\"name\":\"hoxis\",\"age\":18&#125;&gt;&gt;&gt; \"hello, &#123;name&#125;. you are &#123;age&#125;?\".format(**person)'hello, hoxis. you are 18?' (3)f-Strings是指以 f 或 F 开头的字符串，其中以 {} 包含的表达式会进行值替换。f-string 里的 f 也许可以代表 fast，它比 %格式化方法和 str.format() 都要快： 1234567891011121314151617181920212223242526272829303132333435363738394041&gt;&gt;&gt; name = 'hoxis'&gt;&gt;&gt; age = 18&gt;&gt;&gt; f\"hi, &#123;name&#125;, are you &#123;age&#125;\" # 替换字符串'hi, hoxis, are you 18'&gt;&gt;&gt; F\"hi, &#123;name&#125;, are you &#123;age&#125;\"'hi, hoxis, are you 18'&gt;&gt;&gt; f\"&#123;name.lower()&#125; is handsome.\" # 调用函数'hoxis is handsome.'&gt;&gt;&gt; class Person:... def __init__(self,name,age):... self.name = name... self.age = age... def __str__(self):... return f\"&#123;self.name&#125; is &#123;self.age&#125;\" # 在类中使用... def __repr__(self):... return f\"&#123;self.name&#125; is &#123;self.age&#125;. HAHA!\"...&gt;&gt;&gt; hoxis = Person(\"hoxis\",18)&gt;&gt;&gt; f\"&#123;hoxis&#125;\"'hoxis is 18'&gt;&gt;&gt; f\"&#123;hoxis!r&#125;\"'hoxis is 18. HAHA!'&gt;&gt;&gt; print(hoxis)hoxis is 18&gt;&gt;&gt; hoxishoxis is 18. HAHA!&gt;&gt;&gt; name = 'hoxis'&gt;&gt;&gt; age = 18&gt;&gt;&gt; status = 'Python'&gt;&gt;&gt; message = &#123;... f'hi &#123;name&#125;.'... f'you are &#123;age&#125;.'... f'you are learning &#123;status&#125;.'... &#125; # 多行f-string&gt;&gt;&gt;&gt;&gt;&gt; message&#123;'hi hoxis.you are 18.you are learning Python.'&#125; （4）f-string在python3.8中加入新特性，可以在表达式的末尾添加=,此时可以同时显示表达式和值 123&gt;&gt;&gt; python &#x3D; 3.8&gt;&gt;&gt; f&#39;&#123;python&#x3D;&#125;&#39;&#39;python &#x3D; 3.8&#39; 2.2.2. 列表、元组、字典、集合的区别 特点 列表 列表是一组任意类型的值，按照一定的顺序组合而成； 通过索引来标识元素，第一个索引为0；需要注意的是索引可以是负值； 3列表中元素是任意类型的，包括列表类型； 可以进行合并，删除，索引，切片等操作； 5 定义表使用中括号。 元组 元组是任意对象的有序集合（这一点和列表相同）；元组是不可变的（不能 增，删，改），但可以对元组进行合并；元组的速度比列表要快；定义元组使用小括号；需要注意的是定义一个元素时需要加上逗号，例如tuple=（333，）。 字典 字典是通过键值对进行存储的，所以字典没有顺序；字典是通过键值进行索引的且键值必须唯一； 字典可以进行增，删，改，查等操作，可以包含任意其他类型；定义字典使用大括号，各个键值对之间使用逗号隔开。 集合 集合是简单对象的无序不重复元素集合； 集合分为可变集合set（元素是可哈希的），不可变集合frozenset（元素不可哈希）；可以进行去除重复元素；可以进行并集，交集，差集等。 字典的创建方法： 直接创建：dict = {&#39;name&#39;: &#39;earth&#39;, &#39;port&#39;: 80} 1234567class dict(**kwarg) # **kwargs -- 关键字class dict(mapping, **kwarg) # mapping -- 元素的容器。class dict(iterable, **kwarg) # iterable -- 可迭代对象。dict1 = &#123;\"a\": 1, \"b\": 2&#125;dict2 = &#123;\"c\": 3&#125;dict3 = dict(dict1, **dict2) # dict3 = &#123;\"a\": 1, \"b\": 2, \"c\": 3&#125; 工厂方法： 123items = [('name', 'earth'), ('port', 80)]dict1 = dict(items)dict2 = dict((['name', 'earth'], ['port', '80'])) fromkeys()方法 12dict1 = &#123;&#125;.fromkeys(('x', 'y'), -1) # &#123;'x': -1, 'y': -1&#125;dict2 = &#123;&#125;.fromkeys(('x', 'y')) # &#123;'x': None, 'y': None&#125; 2.3. 运算符与流程控制2.3.1. 运算符 运算符优先级：无需记录运算符的优先级，需要的时候添加()即可。 灵活的or：a = False or 2， 赋值前会判断前面的值，若为真则使用，若为假，则使用or后面的值 海象表达式:=:python3.8引入的新语法，将给变量赋值，这个变量可以是表达式的一部分。 123456789101112# 用在if中可以避免调用len()两次if (n := len(a)) &gt; 10: print(f'List is too long (&#123;n&#125; elements, expected &lt;= 10)')# 正则表达式匹配和获取结果的时候discount = 0.00if (mo := re.search(r'(\\d+)% discount', advertisement)): discount = float(mo.group(1)) / 100.0# 用在while循环语句中，可以同时取值，并判断是否为空while (block := f.read(256) != ''): process(block) 2.3.2. 流程控制 列表生成式： 12345print([i for i in range(1, 11)])print([i*2 for i in range(1, 11)])print([i*i for i in range(1, 11)])print([str(i) for i in range(1, 11)])print([i for i in range(1, 11) if i % 2 == 0]) 冒泡排序法：每次比较相邻的两个元素，不合适就交换，依次向后，一圈下来可以确定一个元素；需要使用双重循环，外层循环控制循环的圈数， 内层控制一圈怎么交换 12345678910111213141516171819def bubble_sort(lt, key=None, reverse=False): for i in range(len(lt) - 1): for j in range(len(lt) - 1 - i): if key == None: temp = lt[i] &lt;= lt[i + 1] if reverse else lt[i] &gt; lt[i + 1] else: temp = key(lt[i]) &lt;= lt[i + 1] if reverse else key(lt[i]) &gt; key(lt[i + 1]) if temp: lt[i], lt[i + 1] = lt[i + 1], lt[i] print(lt) lt1 = [1, 5, 2, 1, 4, 9]lt2 = [ &#123;'name': 'xiaoming', 'age': 12, 'height': 160&#125;, &#123;'name': 'xiaohua', 'age': 17, 'height': 140&#125;, &#123;'name': 'xiaogang', 'age': 11, 'height': 180&#125;]choose_sort(lt1)choose_sort(lt2, key=lamamb x: x['age']) 选择排序法：每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 1234567891011121314151617181920def choose_sort(lt, key=None, reverse=False): for i in range(len(lt) - 1): for j in range(i + 1, len(lt)): if key == None: temp = lt[i] &lt;= lt[j] if reverse else lt[i] &gt; lt [j] else: temp = key(lt[i]) &lt;= key(lt[j]) if reverse else key(lt[i]) &gt; key(lt[j]) if temp: lt[i], lt[j] = lt[j], lt[i] print(lt) lt1 = [1, 5, 2, 1, 4, 9]lt2 = [ &#123;'name': 'xiaoming', 'age': 12, 'height': 160&#125;, &#123;'name': 'xiaohua', 'age': 17, 'height': 140&#125;, &#123;'name': 'xiaogang', 'age': 11, 'height': 180&#125;]choose_sort(lt1)choose_sort(lt2, key=lamamb x: x['age'])","link":"","tags":[{"name":"Python","slug":"Python","permalink":"https://lajos182.github.io/tags/Python/"}]},{"title":"No.1 Python简介与版本介绍","date":"2020-04-27T04:08:33.000Z","path":"2020/04/27/No-1-Python简介与版本介绍/","text":"1.1. Python简介 Python是一种解释型(不需要编译)、面向对象、动态数据类型的交互式语言，Python是由由荷兰人Guido van Rossum于1989年发明，第一个公开发行版发行于1991年。 Python的优势： 易于学习：Python有相对较少的关键字，结构简单，有明确定义的语法，学习起来相对简单。 易于阅读：Python代码的定义比较清晰，易于阅读。 易于维护：Python的成功在于它的源代码是相当容易维护。 具有一个广泛的标准库：Python的最大优势之一是具有丰富的库，可跨平台，兼容性较好。 互动模式：互动模式的支持，您可以从终端输入执行代码并获得结果的语言，互动的测试和调试代码的片段。 可移植：基于其开放源代码的特性，Python已经被移植到许多平台。 可扩展性：如果需要一段运行很快的关键代码，或者想要编程一些不愿开放的算法，你可以使用c或者c++完成那部分程序，然后从你的Python程序中进行调用。 GUI编程：Python支持GUI可以创建和移植到许多系统调用。 可嵌入：你可以将Python嵌入到c/c++程序中，让你的程序用户得到“脚本”的能力。 缺点： 运行速度慢：和C程序相比比较慢，因为Python是解释型语言，代码在执行时会一行一行的编译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。 代码不能加密：如果要发布Python程序，实际上就是发布源代码，这一点与C语言不同,C语言不能发布源代码，只需要把编译后的机器码（也就是windows上常见的xxx.exe文件）发布出去。要从机器码反推出C代码是不可能的，所以，凡是编译型的语言，都没有这个问题，而解释型的语言，则必 1.2. Python的设计模式设计模式的定义：为了解决面向对象系统中重要和重复的设计封装在一起的一种代码实现框架,可以使得代码更加易于扩展和调用。 设计模式的基本要素：模式名称、问题、解决方案、效果。 设计模式的六大原则： 开闭原则：一个软件实体,如类,模块和函数应该对扩展开发,对修改关闭.既软件实体应尽量在不修改原有代码的情况下进行扩展。 里氏替换原则：所有引用父类的方法必须能透明的使用其子类的对象。 依赖倒置原则：高层模块不应该依赖底层模块,二者都应该依赖其抽象,抽象不应该依赖于细节,细节应该依赖抽象,换而言之,要针对接口编程而不是针对实现编程。 接口隔离原则：使用多个专门的接口,而不是使用单一的总接口,即客户端不应该依赖那些并不需要的接口。 迪米特法则：一个软件实体应该尽可能的少与其他实体相互作用。 单一职责原则：不要存在多个导致类变更的原因.即一个类只负责一项职责。 Python的设计模式： 二十三设计模式案例详情，可参考：https://www.cnblogs.com/Liqiongyu/p/5916710.html 1.3. 单例模式 单利模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。 1&#96;__new__()&#96;在&#96;__init__()&#96;之前被调用，用于生成实例对象。利用这个方法和类的属性的特点可以实现设计模式的单例模式。单例模式是指创建唯一对象，单例模式设计的类只能实例 **这个绝对常考啊.绝对要记住1~2个方法,当时面试官是让手写的.** 1.3.1. 使用__new__方法__new__是真正创建实例对象的方法，所以重写基类的__new__方法，以此来保证创建对象的时候只生成一个实例 12345678910111213class Singleton(object): _instance = None def __new__(cls, *args, **kwargs): if cls._instance == super(Singlento, cls).__new__(cls, *args, **kwargs) return cls._instanceclass Foo(Signleton): passfoo1 = Foo()foo2 = Foo()print(foo1 is foo2) # True 1.3.2. 使用装饰器装饰器维护一个字典对象instances，缓存了所有单例类，只要单例不存在则创建，已经存在直接返回该实例对象。 12345678910111213141516def singleton(cls): instances = &#123;&#125; def wrapper(*args, **kwargs): if cls not in instances: instances[cls] = cls(*args, **kwargs) return instance[cls] return wrapper@singletonclass Foo(object): passfoo1 = Foo()foo2 = Foo()print(foo1 is foo2) # True 1.3.3. 使用元类元类（参考：深刻理解Python中的元类）是用于创建类对象的类，类对象创建实例对象时一定会调用__call__方法，因此在调用__call__时候保证始终只创建一个实例即可，type是python中的一个元类。 123456789101112131415class Singleton(type): def __call__(cls, *args, **kwargs): if not hasattr(cls, '_instance'): cls._instance = super(Singleton, cls).__call__(*args, **kwargs) return cls._instance class Foo(object): __metaclass__ = Singleton foo1 = Foo()foo2 = Foo() print(foo1 is foo2) # True 1.3.4. import方法import作为python的模块，是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。如果我们真的想要一个单例类，可以考虑这样做： 12345class My_Singleton(object): def foo(self): pass my_singleton = My_Singleton() 将上面的代码保存在文件 mysingleton.py 中，然后这样使用： 123from mysingleton import my_singleton my_singleton.foo() 单例模式伯乐在线详细解释 1.4. Python中的元类(metaclass)这个非常的不常用,但是像ORM这种复杂的结构还是会需要的,详情请看:http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python，中文看这个解释很详细深刻理解Python中的元类 Python处处皆对象，类其实也是对象，使用class关键字时，Python会自动创建此对象。但与Python中的大多数内容一样，type为您提供了手动执行此操作的方法。type有一个完全不同的能力，它也可以动态创建类。type可以将类的描述作为参数，并返回一个类。 123456789type(类名, 类名的元组(针对继承的情况，可以为空), 包含属性的字典(名称和值))&gt;&gt;&gt; Foo = type('Foo', (), &#123;'bar': True&#125;)&gt;&gt;&gt; print(Foo)True&gt;&gt;&gt; f = Foo()&gt;&gt;&gt; print(f)&lt;__main__.Foo object at 0x8a9b84c&gt;&gt;&gt;&gt; print(f.bar)True 1.5. Python自省这个也是python彪悍的特性. 自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type()，dir()，getattr()，hasattr()，isinstance() 1.5.1. 访问对象的属性dir([obj])：调用这个方法将返回包含obj大多数属性名的列表（会有一些特殊的属性不包含在内）。obj的默认值是当前的模块对象。 hasattr(obj, attr)：这个方法用于检查obj是否有一个名为attr的值的属性，返回一个布尔值。 getattr(obj, attr)：调用这个方法将返回obj中名为attr值的属性的值，例如如果attr为’bar’，则返回obj.bar。 setattr(obj, attr, val)：调用这个方法将给obj的名为attr的值的属性赋值为val。例如如果attr为’bar’，则相当于obj.bar = val。 123456789101112131415161718class Cat(object): def __init__(self, name, *args, **kwargs): self.name = name def sayHi(self): print(self.name)cat = Cat('kitty')print(cat.name)cat.sayHi()print(dir(cat)) # 获取实例的属性名，以列表形式返回&gt;&gt;&gt; ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'name', 'sayHi']if hasattr(cat, 'name'): # 检查实例是否有这个属性 setattr(cat, 'name', 'tiger') # same as: a.name = 'tiger'print(getattr(cat, 'name')) # same as: print(a.name)getattr(cat, 'sayHi')() # same as: cat.sayHi() 1.5.2. insepect模块自省is{module|class|function|method|builtin}(obj)：检查对象是否为模块、类、函数、方法、内建函数或方法。 isroutine(obj)：用于检查对象是否为函数、方法、内建函数或方法等等可调用类型。用这个方法会比多个is()更方便，不过它的实现仍然是用了多个is()。 getmembers(object[, predicate])：这个方法是dir()的扩展版，它会将dir()找到的名字对应的属性一并返回，形如[(name, value), …]。另外，predicate是一个方法的引用，如果指定，则应当接受value作为参数并返回一个布尔值，如果为False，相应的属性将不会返回。使用is*作为第二个参数可以过滤出指定类型的属性。 getmodule(object)：返回object的定义所在的模块对象。 get{file|sourcefile}(object)：获取object的定义所在的模块的文件名|源代码文件名（如果没有则返回None）。用于内建的对象（内建模块、类、函数、方法）上时会抛出TypeError异常。 get{source|sourcelines}(object)：获取object的定义的源代码，以字符串|字符串列表返回。代码无法访问时会抛出IOError异常。只能用于module/class/function/method/code/frame/traceack对象。 getargspec(func)：仅用于方法，获取方法声明的参数，返回元组，分别是(普通参数名的列表, 参数名, *参数名, 默认值元组)。如果没有值，将是空列表和3个None。如果是2.6以上版本，将返回一个命名元组(Named Tuple)，即除了索引外还可以使用属性名访问元组中的元素。 getargvalues(frame)：仅用于栈帧，获取栈帧中保存的该次函数调用的参数值，返回元组，分别是(普通参数名的列表, 参数名, *参数名, 帧的locals())。如果是2.6以上版本，将返回一个命名元组(Named Tuple)，即除了索引外还可以使用属性名访问元组中的元素。 getcallargs(func[, *args][, **kwds])：返回使用args和kwds调用该方法时各参数对应的值的字典。这个方法仅在2.7版本中才有。 getmro(cls)：返回一个类型元组，查找类属性时按照这个元组中的顺序。如果是新式类，与cls.__mro__结果一样。但旧式类没有__mro__这个属性，直接使用这个属性会报异常，所以这个方法还是有它的价值的。 currentframe()：返回当前的栈帧对象。 1.6. Python中的重载引自知乎:http://www.zhihu.com/question/20053359 函数重载的目的：解决可变参数类型、可变参数个数两大问题。 另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。 函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。 函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是缺省参数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。 1.7. 新式类和旧式类stackoverflow 在Python 2.1中，旧式类是用户可用的唯一风格。 （旧式）类的概念与类型的概念无关：如果x是旧式类的实例，则x.__class__ 指定类的类x，但type(x)始终是&lt;type &#39;instance&#39;&gt;。 这反映了这样一个事实，即所有旧式实例独立于其类，都使用一个称为实例的内置类型实现。 Python 2.2中引入了新式类，以统一类和类型的概念。新式类只是用户定义的类型，不多也不少。 如果x是新样式类的实例，那么type(x)通常是相同的x.__class__（尽管不能保证 - 允许新样式类实例覆盖返回的值x.__class__）。 引入新式类的主要动机是提供具有完整元模型的统一对象模型。 它还具有许多直接的好处，例如能够对大多数内置类型进行子类化，或引入“描述符”，从而启用计算属性。 出于兼容性原因，默认情况下类仍为旧式。 通过将另一个新样式类（即类型）指定为父类来创建新样式类，或者如果不需要其他父类，则创建“顶级类型”对象。 除了返回的类型之外，新样式类的行为在许多重要细节中与旧样式类的行为不同。 其中一些更改是新对象模型的基础，就像调用特殊方法的方式一样。其他是针对兼容性问题之前无法实现的“修复”，例如在多重继承的情况下的方法解析顺序。 Python 3只有新式的类。 无论你是否是子类object，类都是Python 3中的新风格。这篇文章很好的介绍了新式类的特性: http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html 一个旧式类的深度优先的例子 123456789101112131415161718class A(): def foo1(self): print('A')class B(A): def foo2(self): pass class C(A): def foo1(self): print('C') class D(B, C): passd = D()d.foo1()&gt;&gt;&gt; C 按照经典类的查找顺序从左到右深度优先的规则，在访问d.foo1()的时候,D这个类是没有的..那么往上查找,先找到B,里面没有,深度优先,访问A,找到了foo1(),所以这时候调用的是A的foo1()，从而导致C重写的foo1()被绕过。但在新式类种，按照广度优先的原则，访问d.foo1()时，D没有，继续找B，发现B里面也没有foo1()，再找C， C中有foo1()，直接就调用该方法，输入结果就是C。 1.8. 鸭子模型Python崇尚鸭子类型，即‘如果看起来像、叫声像而且走起路来像鸭子，那么它就是鸭子 python程序员通常根据这种行为来编写程序。例如，如果想编写现有对象的自定义版本，可以继承该对象。 也可以创建一个外观和行为像，但与它无任何关系的全新对象，后者通常用于保存程序组件的松耦合度。 1.9. Python中的作用域Python中，程序的变量并不是哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python的作用域一共有4种，分别是： L（Local） 局部作用域 E（Enclosing）闭包函数外的函数中 G（Global）全局作用域 B（Bulit-in）内置作用域（内置函数所在模块的范围） Python执行时查找作用域的顺序是L-E-G-B，即：先在局部找，局部找不到去局部外的局部(闭包)，然后是全局再到内建 12345g_count = 0 # 全局作用域def outer(): o_count = 1 # 闭包函数外的函数中 def inner(): i_count = 2 # 局部作用域 1.10. GIL线程全局锁线程全局锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制,说白了就是一个核只能在同一时间运行一个线程.对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。 见Python 最难的问题 解决办法就是多进程和下面的协程(协程也只是单CPU,但是能减小切换代价提升性能). 1.11. Python里的拷贝1.12. Python垃圾回收机制Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。 1.12.1. 引用计数PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少.引用计数为0时，该对象生命就结束了。 优点: 简单 实时性 缺点: 维护引用计数消耗资源 循环引用 1.12.2. 标记-清除机制基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。 1.12.3. 分代技术分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。 Python默认定义了三代对象集合，索引数越大，对象存活时间越长。 举例： 当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。 1.13. Python2.x与Python3.x区别Python2.x与Python3.x区别","link":"","tags":[{"name":"Python","slug":"Python","permalink":"https://lajos182.github.io/tags/Python/"}]}]