[{"title":"hexo+github快速制作个人博客","date":"2020-05-07T01:06:09.000Z","path":"2020/05/07/hexo-github快速制作个人博客/","text":"1. 为何采用Github pages服务Hexo是一个简单、快速、强大的基于 Github Pages的博客发布工具，支持Markdown格式，有众多优秀插件和主题。 使用github pages服务搭建博客的好处有： （1）全是静态文件，访问速度快； （2）免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； （3）可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； （4）数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； （5）博客内容可以轻松打包、转移、发布到其它平台； 2. 准备工作在开始一切之前，首先要准备以下工作： Github账号，https://github.com/ node.js、npm，http://nodejs.cn/download/ git for windows(或者其他git客户端)，https://git-scm.com/downloads 3. 搭建博客3.1 创建仓库（1）直接打开Github官网，完成注册 （2） 创建仓库：新建一个名为github用户名.github.io的仓库，比如，github用户名为lajos182，那么就新建lajos182.github.io的仓库(其他名称无效)，以后部署上线就可以使用http://lajos182.github.io(如果使用https，就使用https://lajos182.github.io)访问 3.2 绑定域名如果不绑定域名就用默认的 xxx.github.io 来访问，如果你想拥有一个属于自己的域名，那也是OK的； 首先注册一个域名，域名注册可以去godaddy，阿里云、腾讯云等； 绑定域名分2种情况：带www和不带www的； 域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下github用户名.github.io的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向github用户名.github.io，这样可以保证无论是否添加www都可以访问，如下： 然后到你的github项目根目录新建一个名为CNAME的文件（无后缀），里面填写解析后的域名。注意，在绑定了新域名之后，原来的github用户名.github.io并没有失效，而是会自动跳转到你的新域名。 3.3 配置SSH key提交代码肯定要拥有github权限才可以，但是直接使用用户名和密码太不安全了，所以使用ssh key来解决本地和服务器的连接问题。 用git bash执行如下命令： 1$ cd ~/. ssh #检查本机已存在的ssh密钥 如果提示：No such file or directory，就使用下面的命令生成密钥： 1$ ssh-keygen -t rsa -C \"邮件地址\" 然后连续3次回车，最终会在用户目录下生成一个.ssh目录，找到.ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开github主页，进入个人设置 -&gt;SSH and GPG keys -&gt; New SSH key，配置好密钥即可。 3.4 hexo安装并初始化（1）安装hexo：首先确保电脑已经安装node.js和npm，可以通过下面的命令进行验证是否已经安装： 12$ node -v$ npm -v 如果直接显示出对应的版本号表示已经安装，当然还要确保电脑已经配置好环境变量。然后输入命令安装hexo： 1$ npm install -g hexo （2）克隆仓库至本地：如果无法克隆空仓库，可以现在仓库新建一个README.md文件，里面可以暂时写一些介绍。 1$ git clone git@github.com:lajos182/lajos182.github.io.git # 后面是创建的仓库地址 （3）找到lajos182.github.io所在目录，创建一个hexo（可以随便取个名字）分支，这是方便以后多台电脑同步。 12$ cd lajos182.github.io/$ git branch hexo （4）切换至hexo分支，初始化： 1$ hexo init hexo会自动下载一些文件至lajos182.github.io目录，包含node_modules，此时创建一个.gitignore文件，里面包含以下内容： 1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 此时的目录结构如下： 这时，使用下面的命令启动服务后，在浏览器访问 http://localhost:4000 即可看到内容，可能会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口4000被占用的缘故，解决端口冲突问题请参考这篇文章：http://blog.liuxianan.com/windows-port-bind.html。 12$ hexo g # 生成$ hexo s # 启动服务 3.5 hexo修改主题第一次初始化的时候hexo已经帮我们写了一篇名为 Hello World 的文章，默认的主题比较丑，所以可以进行修改。hexo常用的主题可以看知乎这个推荐https://www.zhihu.com/question/24422335/answers/updated。 博主采用hexo-theme-yilia-plus这个主题，这个主题是根据hexo-theme-yilia主题做了一些优化和改动，详情可以直接点击上面的链接查看。 预览效果： 电脑端： 移动端： （1）下载主题： 12$ cd lajos182.github.io/$ git clone https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FJoeyBling%2Fhexo-theme-yilia-plus themes/yilia-plus # 注意放到themes/yilia-plus目录下 下载后的主题都在目录themes下： （2）修改全局配置_config.yml：就是根目录下的这个文件，下面配置中的xxxxxx可以根据自己来进行配置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: xxxxxsubtitle: xxxxxxdescription: xxxxxxkeywords: xxxxxxauthor: Lajoslanguage: zh-Hanstimezone: Asia/Shanghai# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: xxxxxx # 例如，https://lajos182.github.io/root: /permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing 'index.html' from permalinks trailing_html: true # Set to false to remove trailing '.html' from permalinks# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render: - screenshots/** - anires/** - screenshots/** - gitment/** - baidu_sitepush/** - canvas_nest/** - '*.html' - '*.js' - README.md - '*.sh' - '*.txt' - '*.md'# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # enable: true # Open external links in new tab # field: site # Apply to the whole site # exclude: ''filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: '' # wrap: true # hljs: false# Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -date #top: 1 #date: -1# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Metadata elements## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/metameta_generator: true# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss## Use post's date for updated date unless set in front-matter# use_date_for_updated: false# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Include / Exclude file(s)## include:/exclude: options only apply to the 'source/' folderinclude:exclude:ignore:# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yilia-plus# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:github用户名/github用户名.github.io.git # 这里是重点，例如git@github.com:lajos182/lajos182.github.io.git，起始就是仓库的地址 branch: master # 默认提交的分支是master，所以博主创建了hexo分支保存hexo配置及md博客文件jsonContent: file: content.json meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: true permalink: false excerpt: false categories: false tags: true# Extensionsplugins: hexo-generator-feed# Feed Atomfeed: type: atom path: atom.xml limit: 20# https://github.com/JoeyBling/hexo-filter-imagefilter_image: # 日志是否启用 log: true （3）修改主题下面的_config.yml：这个配置是themes/yilia-plus/_config.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286# Header-菜单menu: 主页: / 日记: /tags/随笔/ Python: /tags/Python/# subNav-子导航subNav: github: \"xxxxxx\" gitee: \"xxxxxx\" # 码云 # jianshu: \"#\" #简书 # cnblog: \"#\" #blog: \"#\" csdn: \"xxxxxx\" #rss: \"#\" zhihu: \"xxxxxx\" #qq: \"img/2434387555.jpg\" #weixin: \"img/weixin_.png\" weibo: \"xxxxxx\" #douban: \"#\" #segmentfault: \"#\" #bilibili: \"#\" #acfun: \"#\" #mail: \"mailto:liujinag_183@qq.com\" #facebook: \"#\" #google: \"#\" #twitter: \"#\" #linkedin: \"#\"# 悬停预览图片效果hover_effect: ## `global` 0: Set separately, 1: Enable global 2: Close global ## `global` 0: 分开设置, 1: 全局启用, 2: 全局关闭 global: 1 # SubNav-导航 subNav: true# RSS订阅(关于如何配置启用:https://www.jianshu.com/p/2aaac7a19736)rss: /atom.xml# 是否需要修改 root 路径# 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，# 请将您的 url 设为 http://yoursite.com/blog 并把 / 设为 /blog/。# 新版本已弃用，请在博客根目录文件进行配置# root: /# Content# 文章太长，截断按钮文字(在需要截断的行增加此标记：&lt;!--more--&gt;)excerpt_link: more# 文章卡片右下角常驻链接，不需要请设置为falseshow_all_link: '展开全文'# 数学公式mathjax: false# Open link in a new tab | 是否在新窗口打开链接open_in_new: article: false # 文章链接 menu: false # 导航菜单 subNav: false # 子菜单# 打赏# 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏reward_type: 2# 打赏wordingreward_wording: '谢谢你请我吃糖果'# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpgalipay: /img/alipay.jpg# 微信二维码图片地址weixin: /img/weixin.png# 目录# 目录设定：0-不显示目录； 1-文章对应的md文件里有toc:true属性，才有目录； 2-所有文章均显示目录toc: 1# 根据自己的习惯来设置，如果你的目录标题习惯有标号，置为true即可隐藏hexo重复的序号；否则置为falsetoc_hide_index: true# 目录为空时的提示toc_empty_wording: '目录，不存在的…'# 是否有快速回到顶部的按钮top: true# Miscellaneous# 百度统计baidu_analytics: ''google_analytics: ''# 网站图标favicon: /img/favicon.ico# 你的头像urlavatar: /img/me.png# 是否开启分享share_jia: true# 评论：1、畅言；2、Disqus；3、Gitment；4、Giteement# 不需要使用某项，直接设置值为false，或注释掉# 具体请参考wiki：https://github.com/JoeyBling/hexo-theme-yilia-plus/wiki# 1、畅言changyan_appid: falsechangyan_conf: false# 2、Disqus 在hexo根目录的config里也有disqus_shortname字段，优先使用yilia-plus的disqus: false# 3、Gitment----基于GitHub的评论系统(关闭请设置gitment_owner为false)# 关于如何集成:https://www.jianshu.com/p/ac7658cc912fgitment_owner: lajos182 #你的 GitHub ID# 是否使用官方js(false可以提升访问速度，本地修改过一部分的js，官方js可能会出现服务器不稳定，不太建议使用)gitment_remote: falsegitment_repo: 'xxxxxx' #存储评论的 repo name(需要在Github创建),例如'lajos182.github.io'gitment_oauth: client_id: 'xxxxxx' #client ID client_secret: 'xxxxxx' #client secret# 4、Giteement----【国内用户建议使用这个，相对比较快】# 关于如何集成:https://www.jianshu.com/p/f5c4633524c7# 基于码云的评论系统(https://gitee.com/zhousiwei/giteement)giteement: enable: false # 是否启用码云评论系统 # 是否使用官方js(false可以提升访问速度) remote: false redirect_uri: '' # 应用回调地址(请和配置的第三方应用保持一致) # 不能更改(网上开源项目`https://github.com/Rob--W/cors-anywhere`作者提供的专门用来跨域服务器的配置) oauth_uri: https://cors-anywhere.herokuapp.com/https://gitee.com/oauth/token giteeID: '' # 你的码云账号英文名 # 存储评论的 repo name(需要在码云仓库创建公开仓库) repo: '' gitment_oauth: client_id: '' #client ID client_secret: '' #client secret# 访问量统计功能(不蒜子)busuanzi: enable: true site_visit: true # 站点访问量显示 article_visit: true # 文章访问量显示# 网易云音乐插件music: enable: true # 播放器尺寸类型(1：长尺寸、2：短尺寸) type: 2 id: 570218574 # 网易云分享的音乐ID(更换音乐请更改此配置项) autoPlay: false # 是否开启自动播放 # 提示文本(关闭请设置为false) text: '这是博主分享的音乐，请尽情的欣赏它吧！'# 页面点击小红心clickLove: # (关闭请设置为false) enable: true# GitHub Ribbons(https://github.blog/2008-12-19-github-ribbons/)github: # (关闭请设置为false) url: xxxxxx# 页脚 Litten(此配置项已弃用)# 帮助我们让更多人可以更方便使用Hexo，请尽量不要修改此主题配置pageFooter: litten: GitHub:&lt;a href=\"https://github.com/JoeyBling/hexo-theme-yilia-plus\" target=\"_blank\"&gt;hexo-theme-yilia-plus&lt;/a&gt;# 开启百度站长平台自动推送(https://ziyuan.baidu.com/linksubmit/index)baidu_push: false# 版权声明# 版权声明type设定：0-关闭版权声明； 1-文章对应的md文件里有copyright: true属性，才有版权声明； 2-所有文章均有版权声明copyright_type: 2# 版权声明自定义文本(关闭请设置为false)copyright_text: # 网站成立年份(默认为 2018，若填入年份小于当前年份，则显示为 2018-2019 类似的格式)since: 2020# Progress Bar | 页面加载进度条# Demo: http://github.hubspot.com/pace/docs/welcome/# type: barber-shop|big-counter|bounce|center-atom|center-circle|# center-radar|center-simple|corner-indicator|flash|flat-top|# loading-bar|mac-osx|minimal# color: black|blue|green|orange|pink|purple|red|silver|white|yellow|progressBar: enable: true type: 'corner-indicator' # Keep Quotes | 保留引号避免出错(某些type会导致样式重叠排版错误) color: blue# Apple Touch icon 苹果图标(关闭请设置为false)apple_touch_icon: '/apple-touch-icon-180x180.png'# Tab Title Change | 标签页标题切换tab_title_change: enable: true left_tab_title: '(つェ⊂) 我藏好了哦~ ' return_tab_title: '(*´∇｀*) 被你发现啦~ '# https://github.com/willin/hexo-wordcount# 是否开启字数统计(关闭请设置enable为false)# 也可以单独在md文件里Front-matter设置`no_word_count: true`属性，来自定义关闭字数统计word_count: enable: true # 只在文章详情显示(不在首页显示) only_article_visit: true# 文字输入特效# https://github.com/disjukr/activate-power-modeactivate_power_mode: enable: true # 使输入模式丰富多彩 colorful: true # 是否开启摇动 shake: false# 飘雪特效# https://github.com/MlgmXyysd/snow.jssnow: true# 看板娘动态模型插件## https://github.com/JoeyBling/live2d-widget.jslive2d: # (关闭请设置为false) enable: true # 模型名称(取值请参考：https://github.com/JoeyBling/hexo-theme-yilia-plus/wiki/live2d%E6%A8%A1%E5%9E%8B%E5%8C%85%E5%B1%95%E7%A4%BA) model: hibiki display: position: right # 显示位置：left/right(default: 'right') width: 145 # 模型的长度(default: 150) height: 315 # 模型的高度(default: 300) hOffset: 50 # 水平偏移(default: 0) #vOffset: -20 # 垂直偏移(default: -20) mobile: show: true # 是否在移动设备上显示(default: true) scale: 0.6 # 移动设备上的缩放(default: 0.5) react: opacity: 1 # 模型透明度(default: 0.7)# 样式定制 - 一般不需要修改，除非有很强的定制欲望…style: # 头像上面的背景颜色 # header: '#D3D1DC' header: '#4d4d4d' gif: # 是否启用左侧边栏动态图效果 enable: true # 自定义背景图路径(默认可以不设置，提供默认背景图) path: /img/biubiubiu.gif # 右滑板块背景 slider: 'linear-gradient(200deg,#a0cfe4,#e8c37e)'# slider的设置slider: # 是否默认展开tags板块 showTags: true# 智能菜单# 如不需要，将该对应项置为false# 比如#smart_menu:# friends: falsesmart_menu: innerArchive: '所有文章' friends: '友链' aboutme: '关于我'# 友情链接friends: 技术笔记: #网站名称 #网站地址 url: xxxxxx #网站图片(可忽略不写) # img: https://zhousiwei.gitee.io/ibooks/favicon.ico #网站简介(可忽略不写) # description: 记录工作和学习过程中的笔记：Java、前端开发、Hexo博客、聚合支付、Linux笔记、ElasticSearch、ELK日志分析 GitHub: url: xxxxxx 码云: url: https://gitee.com/lajos # 简书: # url: https://www.jianshu.com/u/02cbf31a043a # CSDN: # url: https://blog.csdn.net/sinat_41898105# 关于我aboutme: 主要涉及技术：&lt;br&gt;xxxxxx&lt;br&gt;xxxxxx&lt;br&gt;&lt;br&gt;很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家 （4）添加CNAME文件：文件内容添加绑定的域名 （5）将上面显示的目录结构中的文件、CNAME、READE.md提交至远程hexo分支： 123$ git add .$ git commit -m '提交至hexo分支'$ git push origin hexo （6）hexo常见命令 1234567hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 缩写： 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合命令： 12hexo s -g #生成并本地预览hexo d -g #生成并上传 （7）发布博客并上传 1hexo n \"发布第一个博客\" 进入lajos182.github.io/source/_posts/，找到发布第一个博客.md这个文件，可采用Markdown编辑器进行编写，编写完成后，使用命令生成并上传 （8）提交hexo分支的修改内容： 每次发布完，记得将修改的部分提交至hexo。 3.6 git管理与多端同步为什么会存在这个问题呢？因为刚开始在一台电脑上搭建hexo环境并发布博客后，又换用另外一台新设备继续发布博客，此时发现从github克隆下来的只有网页样式文件，而source目录中的md文件就没有，如果直接发布新博文，就会把原来的博文覆盖掉。 为解决这个问题，上面的教程已经实现了：通过git建立新建一个hexo分支，hexo生成的静态博客文件默认放在master分支上；hexo的源文件（部署环境文件）可以都放在hexo分支上，换用新设备时，直接git clone -b hexo git@github.com:lajos182/lajos182.github.io.git，然后使用npm install安装环境，这样就能看到之前发布的博文*.md文件，发布新博文还是一样的。 3.7 常见的问题（1）域名如何使用https访问？ 进入github官网，打开仓库所在目录，点击settings，在Gighub Pages服务中配置Enforce HTTPS，此时绑定的域名就可以使用https访问 （2）如何添加gitment评论系统？ 进入github主页，打开Settings—&gt;Developer settings—&gt;OAuth Apps—&gt;New OAuth App，进入下面的页面：详细可以参考https://www.jianshu.com/p/f5c4633524c7 （3）hexo的gitment评论跳转问题，登录github后出现跳转地址https://www.lajos.top/?error=redirect_uri_mismatch&amp;error_description=The redirect_uri MUST match the registered callback URL for this application.&amp;error_uri=https://developer.github.com/apps/managing-oauth-apps/troubleshooting-authorization-request-errors/#redirect-uri-mismatch，而且还无法评论 这个问题一般是注册的gitment应用有问题，自己查看主页以及授权回调地址是否正确，http和https也要查看是否与博客的域名地址一致。 （4）上一页和下一页显示问题：使用这个主题可能会出现下面这个问题： 首先找到lajos182.github.io/themes/yilia-plus/layout/_partial/archive.ejs，修改两处，分别在8，9行与37，38行，将&amp;laquo; Prev改为&lt;&lt; 上一页, Next &amp;raque;改为下一页 &gt;&gt;，操作如下： 接着，找到lajos182.github.io/themes/yilia-plus/layout/_partial/script.ejs，crtl + f搜索&amp;laquo; Prev，将改为&lt;&lt; 上一页, 搜索Next &amp;raque;改为下一页 &gt;&gt;，操作如下： 保存完成，输入一下命令： 123$ hexo clean$ hexo g$ hexo d 至此完成修改 4 本文参考http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa https://blog.csdn.net/whbk101/article/details/97300209 https://www.jianshu.com/p/f5c4633524c7","link":"","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://lajos182.github.io/tags/Hexo/"},{"name":"前端","slug":"前端","permalink":"https://lajos182.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Github","slug":"Github","permalink":"https://lajos182.github.io/tags/Github/"}]},{"title":"No.11 Python语言基础--异步IO","date":"2020-05-05T14:55:39.000Z","path":"2020/05/05/No-11-Python语言基础-异步IO/","text":"11.1. 计算密集型与IO密集型 计算密集型：要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。 IO密集型：涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。 多线程和多进程的模型虽然解决了并发问题，但是系统不能无上限地增加线程。由于系统切换线程的开销也很大，所以，一旦线程数量过多，CPU的时间就花在线程切换上了，真正运行代码的时间就少了，结果导致性能严重下降。 由于我们要解决的问题是CPU高速执行能力和IO设备的龟速严重不匹配，多线程和多进程只是解决这一问题的一种方法。 另一种解决IO问题的方法是异步IO。当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。一段时间后，当IO返回结果时，再通知CPU进行处理。 11.2. 协程协程(Corontine)，又称微线程、纤程。 子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。 子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。 协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。 注意，在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断。比如子程序A、B： 123456789def A(): print('1') print('2') print('3')def B(): print('x') print('y') print('z') 假设由协程执行，在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A，结果如下。可以看出，在A中是没有调用B的，所以协程的调用比函数调用理解起来要难一些。 12345612xy3z 看起来A、B的执行有点像多线程，但协程的特点在于是一个线程执行，那和多线程比，协程有何优势？ 协程执行效率极高。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。 不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。 因为协程是一个线程执行，那怎么利用多核CPU呢？ 最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能 Python对协程的支持如何通过generator实现的？ 在generator中，我们不但可以通过for循环来迭代，还可以不断调用next()函数获取由yield语句返回的下一个值。但是Python的yield不但可以返回一个值，它还可以接收调用者发出的参数。 传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列核等待，但一不小心就可能死锁。如果改用协程，生产者生产消息后，直接通过yeild跳转到消费者开始执行，待消费者执行完毕后，切换生产者继续生产，效率极高。 123456789101112131415161718192021222324252627282930313233343536373839# 消费者def consumer(): r = '' while True: n = yield r # 此处的yield接收调用者发出的参数n，并把处理后的结果r返回 if not n: return print(f'[CONSUMER] Consumering &#123;n&#125;...') r = '200 OK'# 生产者def produce(c): c.send(None) # 启动生成器consumer n = 0 while n &lt; 5: n += 1 print(f'[PRODUCER] Producing &#123;n&#125;...') r = c.send(n) # 切换至consumer执行 print(f'[PRODUCER] Consumer return &#123;r&#125;') c.close()c = consumer()produce(c)# 运行结果如下：&gt;&gt;&gt; [PRODUCER] Producing 1...[CONSUMER] Consumering 1...[PRODUCER] Consumer return 200 OK[PRODUCER] Producing 2...[CONSUMER] Consumering 2...[PRODUCER] Consumer return 200 OK[PRODUCER] Producing 3...[CONSUMER] Consumering 3...[PRODUCER] Consumer return 200 OK[PRODUCER] Producing 4...[CONSUMER] Consumering 4...[PRODUCER] Consumer return 200 OK[PRODUCER] Producing 5...[CONSUMER] Consumering 5...[PRODUCER] Consumer return 200 OK 运行分析：注意到consumer函数是一个generator，把一个consumer传入produce后： (1)首先调用c.send(None)启动生成器；(2)然后，一旦生产了东西，通过c.send(n)切换到consumer执行；(3)consumer通过yield拿到消息，处理，又通过yield把结果传回；(4)produce拿到consumer处理的结果，继续生产下一条消息；(5)produce决定不生产了，通过c.close()关闭consumer，整个过程结束。 整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。 11.3. asyncioasynio是Python3.4版本引入的标准库，直接内置了对异步IO的支持。它的编程模型就是一个消息循环。我们从asyncio模块中直接获取一个EventLoop的引用，然后把需要执行的协程扔到EventLoop中执行，就实现了异步IO。 asyncio提供了完善的异步IO支持； 异步操作需要在coroutine中通过yield from完成； 多个coroutine可以封装成一组Task然后并发执行。 1234567891011121314151617import asyncio# @asyncio.coroutine把一个generator标记为coroutine类型，然后，我们就把这个coroutine扔到EventLoop中执行。@asyncio.coroutinedef hello(): print('hello world!') # 异步调用asynico.sleep(1)，也是一个coroutine, 所以线程不会等待asynico.sleep()，而是直接中断并执行下一个消息循环。当asyncio.sleep()返回时，线程就可以从yield from拿到返回值（此处是None），然后接着执行下一行语句。asyncio.sleep(1)看成是一个耗时1秒的IO操作，在此期间，主线程并未等待，而是去执行EventLoop中其他可以执行的coroutine了，因此可以实现并发执行。 r = yield from asyncio.sleep(10) print('hello world again!')# 获取EventLooploop = asyncio.get_event_loop()# 执行coroutineloop.run_until_complete(hello())loop.close()&gt;&gt;&gt; hello world!hello world again! 使用task封装两个coroutine: 12345678910111213141516171819import asyncioimport threading@asyncio.coroutinedef hello(): print(f'hello world! (&#123;threading.current_thread()&#125;)') yield from asyncio.sleep(1) print(f'hello world agagin! (&#123;threading.current_thread()&#125;)')loop = asyncio.get_event_loop()tasks = [hello(), hello()]loop.run_until_complete(asyncio.wait(tasks))loop.close()# 运行结果如下：&gt;&gt;&gt; hello world! (&lt;_MainThread(MainThread, started 4020)&gt;)hello world! (&lt;_MainThread(MainThread, started 4020)&gt;)hello world agagin! (&lt;_MainThread(MainThread, started 4020)&gt;)hello world agagin! (&lt;_MainThread(MainThread, started 4020)&gt;)# 由打印的当前线程名称可以看出，两个coroutine是由同一个线程并发执行的。 案例：用asyncio的异步网络连接sina、souhu和163的网站首页 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import asyncio@asyncio.coroutinedef wget(host): print(f'wget &#123;host&#125;...') # 创建TCP客户端并连接服务器，或者说创建一个TCP连接对象 # open_connection接收两个参数：主机和端口号 # connect是协程，这步仅是创建协程对象，立即返回，不阻塞 connect = asyncio.open_connection(host, 80) # 连接创建成功后，asyncio.open_connection方法的返回值就是读写对象 # 读写对象分别为StreamReader和StreamWriter实例 # 它们也是协程对象，底层调用socket模块的send和recv方法实现读写 reader, writer = yield from connect # header 是发送给服务器的消息，意为获取页面的 header 信息 # 这个格式是固定的，见下图 header = f'GET / HTTP/1.0\\r\\nHost: &#123;host&#125;\\r\\n\\r\\n' # 给服务器发消息，注意消息是二进制的 writer.write(header.encode('utf-8')) # 这是一个与底层IO输入缓冲区交互的流量控制方法 # 当缓冲区达到上限时，drain()阻塞，待到缓冲区回落到下限时，写操作恢复 # 当不需要等待时，drain()会立即返回，例如上面的消息内容较少，不会阻塞 # 这就是一个控制消息的数据量的控制阀 yield from writer.drain() # 给服务器发送消息后，就等着读取服务器返回来的消息 while True: # 读取数据是阻塞操作，释放CPU # reader相当于一个水盆，服务器发来的数据是水流 # readline表示读取一行，以\\n作为换行符 # 如果在出现\\n之前，数据流中出现EO（End Of File文件结束符）也会返回 # 相当于出现\\n或EOF时，拧上水龙头，line就是这盆水 line = yield from reader.readline() # 数据接收完毕，会返回空字符串\\r\\n，退出while循环，结束数据接收 if line.decode('utf-8') == '\\r\\n': break # 接收的数据是二进制数据，转换为 UTF-8 格式并打印 # rstrip 方法删掉字符串的结尾处的空白字符，也就是 \\n print(f'&#123;host&#125; header &gt; &#123;line.decode(\"utf-8\").rstrip()&#125;') writer.close() # 关闭数据流，可以省略loop = asyncio.get_event_loop()tasks = [wget(host) for host in ['www.sina.com.cn', 'www.sohu.com', 'www.163.com']]loop.run_until_complete(asyncio.wait(tasks))loop.close()# 运行结果如下(3个连接由一个线程通过coroutine并完成)：&gt;&gt;&gt; wget www.163.com...wget www.sohu.com...wget www.sina.com.cn...www.sohu.com header &gt; HTTP/1.1 200 OKwww.sohu.com header &gt; Content-Type: text/html;charset=UTF-8www.sohu.com header &gt; Connection: closewww.sohu.com header &gt; Server: nginxwww.sohu.com header &gt; Date: Thu, 14 Nov 2019 03:07:07 GMTwww.sohu.com header &gt; Cache-Control: max-age=60www.sohu.com header &gt; X-From-Sohu: X-SRC-Cachedwww.sohu.com header &gt; Content-Encoding: gzipwww.sohu.com header &gt; FSS-Cache: HIT from 111148311605210.19052918www.sohu.com header &gt; FSS-Proxy: Powered by 9410870.10197312.17348930www.163.com header &gt; HTTP/1.1 200 OKwww.163.com header &gt; Date: Thu, 14 Nov 2019 03:07:56 GMTwww.163.com header &gt; Content-Type: text/html; charset=GBKwww.163.com header &gt; Connection: closewww.163.com header &gt; Expires: Thu, 14 Nov 2019 03:09:17 GMTwww.163.com header &gt; Server: nginxwww.163.com header &gt; Cache-Control: no-cache,no-store,privatewww.163.com header &gt; Vary: Accept-Encodingwww.163.com header &gt; X-Ser: BC51_dx-lt-yd-shandong-jinan-5-cache-6, BC51_dx-lt-yd-shandong-jinan-5-cache-6, BC138_dx-zhejiang-zhou-1-cache-3www.163.com header &gt; cdn-user-ip: 60.176.229.93www.163.com header &gt; cdn-ip: 115.231.128.142www.163.com header &gt; X-Cache-Remote: HITwww.163.com header &gt; cdn-source: baishanwww.sina.com.cn header &gt; HTTP/1.1 302 Moved Temporarilywww.sina.com.cn header &gt; Server: nginxwww.sina.com.cn header &gt; Date: Thu, 14 Nov 2019 03:07:56 GMTwww.sina.com.cn header &gt; Content-Type: text/htmlwww.sina.com.cn header &gt; Content-Length: 154www.sina.com.cn header &gt; Connection: closewww.sina.com.cn header &gt; Location: https://www.sina.com.cn/www.sina.com.cn header &gt; X-Via-CDN: f=edge,s=ctc.nanjing.ha2ts4.63.nb.sinaedge.com,c=60.176.229.93;www.sina.com.cn header &gt; X-Via-Edge: 15737008765135de5b03c7c5e66ca1bf1580f 11.4. async/await为了简化并更好地标识异步IO，从Python3.5开始引入新的语法async和await，可以让corountine的代码更简洁易读。与Python3.4的asyncio和yield from的区别： 把@asyncio.coroutine替换为async 把yield from替换为await。 1234567891011121314import asyncioasync def hello(): print('hello world!') r = await asyncio.sleep(10) print('hello world again!')# 获取EventLooploop = asyncio.get_event_loop()# 执行coroutineloop.run_until_complete(hello())loop.close()&gt;&gt;&gt; hello world!hello world again! 11.5. aiohttpaiohttp可以实现单线程并发IO操作。如果仅用在客户端，发货的威力不大。如果把asyncio用在服务端，例如Web服务器，由于HTTP连接就是IO操作，因此可以用单线程+coroutine实现多用户的高并发。 asyncio实现了TCP、UDP、SSL等协议，aiohttp则是基于asyncio实现的HTTP框架。 安装aiohttp：pip install aiohttp 编写HTTP服务器，分别处理以下URL: /-首页返回b&#39;&lt;h1&gt;Index&lt;/h1&gt;&#39;； /hello/{name}-根据URL参数返回文本hello, %s!。 用aiohttp创建服务 123456789101112131415161718192021import asynciofrom aiohttp import webasync def index(request): await asyncio.sleep(0.5) return web.Response(body=b'&lt;h1&gt;Index&lt;/h1&gt;', content_type='text/html')async def hello(request): await asyncio.sleep(0.5) text = f'&lt;h1&gt;hello, &#123;request.match_info[\"name\"]&#125;&lt;/h1&gt;' return web.Response(body=text.encode('utf-8'), content_type='text/html')async def init(loop): app = web.Application(loop=loop) app.router.add_route('GET', '/', index) app.router.add_route('GET', '/hello/&#123;name&#125;', hello) runner = web.AppRunner(app) srv = await loop.create_server(runner, '127.0.0.1', 9000) print('Server started at http://127.0.0.1:9000...') return srv","link":"","tags":[{"name":"Python","slug":"Python","permalink":"https://lajos182.github.io/tags/Python/"},{"name":"异步","slug":"异步","permalink":"https://lajos182.github.io/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"No.10 Python语言基础--线程","date":"2020-05-05T14:32:18.000Z","path":"2020/05/05/No-10-Python语言基础-线程/","text":"10.1. 线程简介 在一个进程中，若想做多个子任务，我们把每个子任务称为线程 线程可以理解为轻量级的进程 进程之间的数据是独立，而一个进程下的线程数据是共享的 线程是CPU分配时间的最小单位，进程和线程的调度都是操作系统的事 一个进程默认都有一个线程，我们称为主线程 10.2. 线程模块Python的标准库提供了两个模块：_thread和threading，_thread是低级模块，threading是高级模块，对_thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。 低级模块(_thread)：非常简陋，不建议使用 1234567891011121314import _threadimport timedef loop(): print('子线程开始') print('子线程结束') if __name__ == '__main__': print('主线程开始') # 创建线程 _thread.start_new_thread(loop, ()) # 主线程结束，子线程立即结束，通过演示测试 time.sleep(3) print('主线程结束') 高级模块(threading) 12345678910111213141516171819202122232425262728293031323334353637import threadingimport timedef run(num): c = threading.current_thread() print('子线程开始：', c.name) time.sleep(3) print(num) print(threading.active_count()) print('子线程结束：', c.name)if __name__ == \"__main__\": # 获取主线程 t = threading.main_thread() print('主线程开始：', t.name) # 获取当前线程 c = threading.current_thread() print('当前线程：', c.name) # 创建子线程 sub = threading.Thread(target=run, args=(250,), name='subthread') # 启动子线程 sub.start() # 活跃线程个数 print(threading.active_count()) # 线程列表 print(threading.enumerate()) time.sleep(1) # 判断线程是否活着 print(sub.is_alive()) # 等待子线程 sub.join() print(sub.is_alive()) print('主线程结束：', t.name) threading.main_thread(): 返回主线程对象。可以通过name属性获取主线程名称，默认MainThread threading.current_thread()：返回当前线程对象，可以通过name属性获取当前线程，默认Thread-N threading.active_count()：返回当前存活的线程个数 threading.enumrate()：以列表形式返回当前所有存活的Thread对象 threading.Thread(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)：构造线程对象 group：应该为None，为了日后扩展ThreadGroup类实现而保留 target：用于任务函数run()调用的可调用对象，默认为None，表示不需要调用任何方法 name：线程名称，默认情况下，由Thread-N格式构成一个唯一的名称，其中N是小的十进制数。 args：用于调用目标函数的参数元组，默认为() kwargs：是用于调用目标函数的关键字参数字典，默认为{} daemon：默认为None，线程将继承当前线程的守护模式属性；不是None，线程将被显式的设置为守护模式，不管该线程是否是守护模式 sub.start()：开始线程活动 sub.run()：代表线程活动的方法。也可以在子类型里重载这个方法，标准的run()方法对作为target参数传递给该对象构造器的可调用对象（如果存在）发起调用，并附带从args和kwargs参数分别获取的位置和关键字参数。 sub.join(timeount=None)：等待，直到线程结束。这会阻塞调用这个方法的线程，直到被调用join()的线程终结。当timeout不为None时，因为join()总是返回None，所以你一定要在join()后调用is_alive()才能判断是否发生超时。 sub.is_active()：判断线程是否存活着 os.exit()：用于退出当前线程 os._exit()：用于退出当前进程中的主线程 10.3. 数据共享全局变量是可以共享的。 123456789101112131415161718192021222324252627import threadingimport timenum = 250def thread_one(): global num num += 10def thread_two(): global num num -= 10if __name__ == \"__main__\": print('主线程开始：', num) t1 = threading.Thread(target=thread_one) t1.start() t1.join() print('主线程：', num) t2 = threading.Thread(target=thread_two) t2.start() t2.join() print('主线程结束：', num)# 运行结果如下：&gt;&gt;&gt; 主线程开始： 250主线程： 260主线程结束： 250 线程之间共享进程的所有数据 10.4. 线程锁多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。 123456789101112131415161718192021222324252627import threadingimport time# 账户余额balance = 250def operate(num): global balance for i in range(1000000): balance += num balance -=numif __name__ == \"__main__\": print('账户初始余额为：', balance) while True: t1 = threading.Thread(target=operate, args=(10,)) t2 = threading.Thread(target=operate, args=(10,)) t1.start() t2.start() t1.join() t2.join() if balance != 250: break print('账户最终余额为：', balance)# 运行结果如下：&gt;&gt;&gt; 账户初始余额为： 250账户最终余额为： 240 在上面的例子中，两个线程同时一存一取，最终导致余额不对，所以我们必须要保证一个线程在修改balance的时候，其他的线程一定不能改。所以，这时候就需要线程锁来做这件事情，当某个线程获取锁之后，除非锁被释放才可以继续执行其他线程，保证同意时刻最多只有一个线程持有该所，这样才不会造成冲突。 threading.Lock()：创建线程锁 12345678910111213141516171819202122232425262728293031323334import threadingimport time# 账户余额balance = 250def operate(num, lock): global balance for i in range(1000000): # lock.acquire() # try: # balance += num # balance -=num # finally: # lock.release() # 可以直接采用with实现锁的创建和释放 with lock: balance += num balance -=numif __name__ == \"__main__\": print('账户初始余额为：', balance) # 创建线程锁对象 lock = threading.Lock() t1 = threading.Thread(target=operate, args=(10, lock)) t2 = threading.Thread(target=operate, args=(10, lock)) t1.start() t2.start() t1.join() t2.join() print('账户最终余额为：', balance)# 运行结果&gt;&gt;&gt; 账户初始余额为： 250账户最终余额为： 250 10.5. 自定义线程自定义线程，需要继承自Thread类，还需要重写run()方法，开启线程时会自动调用run()方法 123456789101112131415161718192021222324252627282930313233343536373839import threadingimport timeclass MyThread(threading.Thread): def __init__(self, time, name): super().__init__() self.time = time self.name = name def run(self): print(f'Sub thread &#123;self.name&#125; start &gt;&gt;&gt;') time.sleep(self.time) print(f'Sub thread &#123;self.name&#125; end &lt;&lt;&lt;')if __name__ == \"__main__\": print('Main thread start...') record = [] for i in range(5): p = MyThread(2, i) p.start() record.append(p) for p in record: p.join() print('Main thread end...')# 运行结果&gt;&gt;&gt; Main thread start...Sub thread 0 start &gt;&gt;&gt;Sub thread 1 start &gt;&gt;&gt;Sub thread 2 start &gt;&gt;&gt;Sub thread 3 start &gt;&gt;&gt;Sub thread 4 start &gt;&gt;&gt;Sub thread 2 end &lt;&lt;&lt;Sub thread 3 end &lt;&lt;&lt;Sub thread 0 end &lt;&lt;&lt;Sub thread 1 end &lt;&lt;&lt;Sub thread 4 end &lt;&lt;&lt;Main thread end... 10.6. 定时线程在threading模块中，有一个Timer类，继承自Thread类，可以延迟执行线程任务。 threading.Timer(interval, function[, args, kwargs])：设置一定时间后执行任务，interval表示设置的时间(s)，function表示要执行的任务，args与kwargs表示传入的参数 timer.start()：开启定时任务 timer.end()：取消定时任务 1234567891011121314151617181920212223242526272829import threadingimport timedef run(name): print(f'Sub thread &#123;name&#125; start time：&#123;time.ctime()&#125;') time.sleep(1) print(f'Sub thread &#123;name&#125; end time：&#123;time.ctime()&#125;')if __name__ == \"__main__\": print('Main thread start...') record = [] for i in range(3): sub = threading.Timer(3, run, args=(i,)) sub.start() record.append(sub) for sub in record: sub.join() print(f'Main thread end time：&#123;time.ctime()&#125;') print('Main thread end...')# 运行结果如下：&gt;&gt;&gt; Main thread start...Sub thread 0 start time：Tue Nov 19 09:53:58 2019Sub thread 1 start time：Tue Nov 19 09:53:58 2019Sub thread 2 start time：Tue Nov 19 09:53:58 2019Sub thread 0 end time：Tue Nov 19 09:53:59 2019Sub thread 1 end time：Tue Nov 19 09:53:59 2019Sub thread 2 end time：Tue Nov 19 09:53:59 2019Main thread end time：Tue Nov 19 09:53:59 2019Main thread end... 10.7. 信号传递(Event)在threading模块中，有一个Event类，可以用来控制线程的执行。 123456789101112131415161718192021import threadingimport timedef run(num): for i in range(num): # 等待条件成立，会阻塞 e.wait() print(f'第&#123;i+1&#125;步...') # 清除条件 e.clear()if __name__ == \"__main__\": print('Main thread start...') e = threading.Event() sub = threading.Thread(target=run, args=(3,)) sub.start() for i in range(3): time.sleep(1) # 设置后，wait处将不在阻塞 e.set() print('走你', end=' ') 10.8. 多核CPU(Python无法利用多线程实现多核任务)如果你用于一个多核CPU，你肯定回想，多核应该可以同时执行多个线程，可以写一个死循环，在N核CPU上执行N个死循环线程，结果会发生什么？ 1234567891011import threading, multiprocessingdef loop(): x = 0 while True: x = x ^ 1if __name__ == \"__main__\": for i in range(multiprocessing.cpu_count()): t = threading.Thread(target=loop) t.start() 启动上面的程序，双核的CPU上可以监控CPU利用率仅有97%，也就是仅使用了一核。但是用C、C++或Java来改写相同的死循环，直接可以把全部核心跑满，4核就跑到400%，8核就跑到800%，为什么Python不行呢？ 因为Python的线程虽然是真正的线程，但解释器执行时，会存在一个全局解释器锁(GIL锁)，任何Python线程执行前，必须先获得GIL锁，然后每执行100条字节码，解释器就会自动释放GIL锁，让别的线程有机会执行，这个GIL锁实际上把所有线程的执行代码都给加了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。 GIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。 所以，在Python中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。 不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。 10.9. 进程 vs 线程 进程 进程是操作系统资源分配的最小单位 进程拥有独立的地址空间，每启动一次进程，系统就会为它分配地址空间 多进程程序更健壮 多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。 多进程模式的缺点是创建进程的代价大，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。 线程 程序执行(调度)的最小单位 线程是共享进程中的数据，使用相同的地址空间，CPU切换一个线程的花费远远小于进程 轻量级的进程，进程之间的数据是独立的，而一个进程下的数据是可以共享的，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。 线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。","link":"","tags":[{"name":"Python","slug":"Python","permalink":"https://lajos182.github.io/tags/Python/"},{"name":"线程","slug":"线程","permalink":"https://lajos182.github.io/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"No.9 Python语言基础--进程","date":"2020-05-04T04:26:11.000Z","path":"2020/05/04/No-9-Python语言基础-进程/","text":"9.1. 进程简介 进程（任务）： 在计算机中，其实进程就是一个任务。 在操作系统中，进程是程序执行和资源分配的基本单元。 单核CPU实现多任务 只是将CPU的时间快速的切换和分配到不同的任务上。 主频足够高，切换足够快，人的肉眼无法分辨而已。 多核CPU实现多任务 如果任务的数量不超过CPU的核心数，完全可以实现一个核心只做一个任务。 在操作系统中几乎是不可能的，任务量往往远远大于核心数。 同样采用轮训的方式，轮流执行不同的任务，只是做任务的’人’有多个而已。 Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。 子进程永远返回0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。 1234567891011121314import osprint(f'Process &#123;os.getpid()&#125; start...')# Only works on Unix/Linux/Mac:pid = os.fork()print(pid)if pid == 0: print(f'I am child process (&#123;os.getpid()&#125;) and my parent is &#123;os.getppid()&#125;)')else: print(f'I (&#123;os.getpid()&#125;) just created a child process &#123;pid&#125;')&gt;&gt;&gt; Process (876) start...I (876) just created a child process (877).I am child process (877) and my parent is 876. 由于Windows没有fork调用，上面的代码在Windows上无法运行。有了fork调用，一个进程在接到新任务时就可以复制出一个子进程来处理新任务，常见的Apache服务器就是由父进程监听端口，每当有新的http请求时，就fork出子进程来处理新的http请求。 9.2. 进程的并发与并行 并发：并发是指在资源有限的情况下，两者交替轮流使用资源，比如一段路(单核CPU资源)同时只能过一个人，A走一段后，让给B，B用完继续给A，交替使用，目的是提高效率。 并行：并行是指两者同时执行，比如赛跑，两个人都在不停的往前跑（资源够用，比如三个线程，四核的CPU）； 区别：并发是从宏观上，在一个时间段上可以看出是同时执行的，比如一个服务器同时处理多个session。并行是从微观上，也就是在一个精确的时间片刻，有不同的程序在执行，这就要求必须有多个处理器。 9.3. 进程管理1234567891011121314from multiprocessing import Processimport osdef run(name): print(f'Run child process &#123;name&#125; (&#123;os.getpid()&#125;)')if __name__ == \"__main__\": print(f'Parent process &#123;os.getpid()&#125;') # 创建进程，指定任务函数，target就是指定任务的函数，name代表进程名称， args和kwargs表示传递给子进程任务函数的参数 p = Process(target=run, args=('test',)) print('Child process will start...') p.start() p.join() print('Child process end...') os.getpid()：获取当前的进程id os.getppid()：获取主进程id Process([group [, target [, name [, args [, kwargs]]]]])：由该类实例化得到的对象，表示一个子进程中的任务（尚未启动），需要使用关键字的方式来指定参数，args指定的为传给target函数的位置参数，是一个元组形式，必须有逗号 -group参数未使用，值始终为None-target表示调用对象，即子进程要执行的任务-name为子进程的名称-args表示调用对象的位置参数元组，args=(1, 2, &#39;egon&#39;,)-kwargs表示调用对象的字典，kwargs={&#39;name&#39;: &#39;egon&#39;, &#39;age&#39;: 18} p.daemone：默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置 p.name：进程的名称 p.pid：进程pid p.exitcode：进程在运行时为None、如果为–N，表示被信号N结束(了解即可) p.authkey：进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可） p.start()：启动进程，并调用该子进程中的p.run() p.run()：进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法 p.terminate()：强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁 p.is_alive()：如果p仍然运行，返回True p.join[timeout])：主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程 9.4. 进程锁当多个进程操作同一资源时，可能会造成混乱，甚至错误（如写文件），通常采用加锁的方式进行解决 12345678910111213141516171819202122232425262728293031323334from multiprocessing import Process, Lockimport osimport timedef run(label, lock): # 获取锁 lock.acquire() time.sleep(1) # 中间的任务，不肯能同时多个进程任务执行 print(label, os.getpid()) # 释放锁 lock.release()if __name__ == '__main__': print('主进程：', os.getpid()) # 创建进程锁 lock = Lock() # 创建多个子进程 # 用于存储所有的进程 recode = [] for i in range(5): p = Process(target=run, args=(f'子进程&#123;i&#125;', lock)) p.start() recode.append(p) # 等待进程结束 for p in recode: p.join()# 运行结果如下：&gt;&gt;&gt; 主进程： 22224子进程0 22288子进程1 22296子进程2 22312子进程3 22328子进程4 22344 9.5. 自定义进程采用继承Process类开启进程的方式 123456789101112131415161718192021from multiprocessing import Process, Lockimport osimport timeclass MyProcess(Process): def __init__(self, name, num=1): super().__init__() self.name = name self.num = num def run(self): for i in range(self.num): print(f'子进程(&#123;i&#125;)运行中...') time.sleep(1) if __name__ == \"__main__\": p = MyProcess('test1') print(f'主进程&#123;p.name&#125;开始启动...') p.start() p.join() 9.6. 进程池创建少量的进程可以通过创建Process对象完成，如果需要大量的进程和管理时就比较费劲。这时，可以通过进程池加以解决，而且可以通过参数控制进程池中进程的并发数，提高CPU利用率（创建进程池–&gt;添加进程–&gt;关闭进程池–&gt;等待进程池结束–&gt;设置回调） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import multiprocessingimport time, randomimport osdef callback(num): print(num)def task(num): print(f'Run task &#123;num&#125; (&#123;os.getpid()&#125;)...') start = time.time() time.sleep(random.random() * 3) end = time.time() print(f'Task &#123;num&#125; runs &#123;(end-start):,.2f&#125; seconds.') return numif __name__ == \"__main__\": # 获取cpu核心数 print('cpu核数：', multiprocessing.cpu_count()) print(f'Parent process &#123;os.getpid()&#125;') # 创建进程池，一般进程池中的进程数不超过cpu核心数 pool = multiprocessing.Pool(4) # 循环创建进程并添加到进程池中 for i in range(5): # 参数： # func：任务函数 # args：任务函数的参数 # callback：回调函数，进程结束时调用，参数是进程函数的返回值 pool.apply_async(func=task, args=(i,), callback=callback) # 如果换用map_async()可以这样来写 # pool.map_async(task, [i for i in range(5)]) print('Waiting for all subporcess done...') # 关闭进程池，关闭后就不能添加进程了 pool.close() # 等待进程结束 pool.join() print('All subprocess done.')# 运行结果如下：&gt;&gt;&gt; cpu核数： 2Parent process 22840Waiting for all subporcess done...Run task 0 (22888)...Run task 1 (22880)...Run task 2 (22904)...Run task 3 (22920)...Task 2 runs 0.48 seconds.Run task 4 (22904)...2Task 0 runs 0.80 seconds.0Task 3 runs 0.71 seconds.3Task 1 runs 1.50 seconds.1Task 4 runs 1.86 seconds.4All subprocess done. Pool([numprocess[, initializer[, initargs]]])：创建进程池，numprocess为要创建的进程数，默认使用multiprocessing.cpu_count()的CPU核心数；initializer是每个工作进程启动时要执行的可调用对象，默认为None；initargs是要传给initializer的参数组。 pool.apply(func[, args[, kwargs]])同步执行(阻塞式)：在一个池工作进程中执行func(*args,**kwargs),然后返回结果，同步运行，阻塞，直到本次任务执行完毕后返回结果。此操作并不会在所有池工作进程中并执行func函数。如果要通过不同参数并发地执行func函数，必须从不同线程调用pool.apply()函数或者使用pool.apply_async()。 pool.map(func, iterable[, chunksize=None])：和pool.apply()类似，只不过需要接收一个可迭代的参数对象。 pool.apply_async(func[, args[, kwargs[, callback=None[, error_callback=None]]]])异步执行(非阻塞)：在一个池工作进程中执行func(*args,**kwargs)，然后返回结果。此方法的结果是AsyncResult类的实例，callback是可调用对象，接收输入参数。当func的结果变为可用时，将理解传给callback。callback禁止执行任何阻塞操作，否则将接收其他异步操作中的结果。 pool.map_async(func, iterable[, chunksize=None[, callback=None[, error_callback=None]]]])：和pool.apply_async()类似，只不过需要接收一个可迭代的参数对象。 9.7. 数据共享Process之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式来交换数据。但要注意的是，全局变量不能共享。 123456789101112131415161718192021222324252627import multiprocessingimport time, randomimport osnum = 250lt = ['hello']def run(): global num, lt print('子进程开始。。。') num += 10 lt.append('world') print('子进程结束：', num, lt)if __name__ == \"__main__\": print('主进程开始》》》', num, lt) p = multiprocessing.Process(target=run) p.start() p.join() print('主进程结束：', num, lt)# 运行结果如下：&gt;&gt;&gt; 主进程开始》》》 250 ['hello']子进程开始。。。子进程结束： 260 ['hello', 'world']主进程结束： 250 ['hello'] 管道(Pipe)：创建管道时，得到两个连接；默认dublex为True，表示全双工，两边都可以收发；若dublex为False，表示半双工，p_a只能收，p_b只能发。 全双工通信： 123456789101112131415161718192021222324252627282930import multiprocessingdef run(p_a): # 子进程接收主进程发的数据 recv = p_a.recv() print('子进程收到：', recv) print('子进程发送：', ['a', 'b', 'c', 'd']) # 子进程给主进程发数据 p_a.send(['a', 'b', 'c', 'd'])if __name__ == \"__main__\": # 创建管道, 默认为全双工 p_a, p_b = multiprocessing.Pipe() p = multiprocessing.Process(target=run, args=(p_a,)) p.start() print('主进程发送：', [1, 2, 3, 4, 5]) # 主进程向子进程发数据 p_b.send([1, 2, 3, 4, 5]) p.join() # 主进程接收子进程的数据 recv = p_b.recv() print('主进程收到：', recv) print('主进程结束')# 运行结果如下：&gt;&gt;&gt; 主进程发送： [1, 2, 3, 4, 5]子进程收到： [1, 2, 3, 4, 5]子进程发送： ['a', 'b', 'c', 'd']主进程收到： ['a', 'b', 'c', 'd']主进程结束 半双工通信：dublex为False，表示半双工，p_a只能收，p_b只能发 12345678910111213141516171819202122import multiprocessing def run(p_a): # 子进程接收主进程发的数据 recv = p_a.recv() print('子进程收到(p_a)：', recv) if __name__ == \"__main__\": # 创建管道, 默认为全双工 p_a, p_b = multiprocessing.Pipe(duplex=False) p = multiprocessing.Process(target=run, args=(p_a,)) p.start() print('主进程发送(p_b)：', [1, 2, 3, 4, 5]) # 主进程向子进程发数据 p_b.send([1, 2, 3, 4, 5]) p.join() # 主进程接收子进程的数据 print('主进程结束') # 运行结果如下： &gt;&gt;&gt; 主进程发送(p_b)： [1, 2, 3, 4, 5] 子进程收到(p_a)： [1, 2, 3, 4, 5] 主进程结束 队列(Queue) Queue本身就是一个消息队列程序，常用的方法有： Queue.qsize()：返回当前消息队列的消息数量。 Queue.empty()：如果队列为空，返回True 否则返回False。 Queue.full()：如果队列满了，返回True，否则False。 Queue.get()：获取队列中的一条消息，然后将其从队列中移除。队列为空时，获取的时候也会阻塞。 Queue.put(&#39;xxx&#39;)：把内容存放进消息队列, 默认为True数据会阻塞，设为False时，如果队列已满会报错。 Queue.close()：关闭队列 Queue.get_nowait()相当于Queue.get(False)。 Queue.put_nowait()相当于Queue.put(False)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import multiprocessingimport osimport timedef put_data(queue): # 拼接数据 data = str(os.getpid()) + ' ' + str(time.time()) print('压入数据：', data) queue.put(data)def get_data(queue): data = queue.get() print('读取数据：', data)if __name__ == \"__main__\": # 创建队列 q = multiprocessing.Queue(3) # 创建5个进程用于写数据 record1 = [] for i in range(5): p = multiprocessing.Process(target=put_data, args=(q,)) p.start() record1.append(p) # 创建5个进程用于读数据 record2 = [] for i in range(5): p = multiprocessing.Process(target=get_data, args=(q,)) p.start() record2.append(p) for p in record1: p.join() for p in record2: p.join()# 运行结果如下&gt;&gt;&gt; 压入数据： 6220 1573552927.6151476压入数据： 5900 1573552927.7400696压入数据： 19276 1573552927.8130243压入数据： 17492 1573552927.9059665压入数据： 16408 1573552927.9929125读取数据： 6220 1573552927.6151476读取数据： 5900 1573552927.7400696读取数据： 19276 1573552927.8130243读取数据： 17492 1573552927.9059665读取数据： 16408 1573552927.9929125 如果采用进程池创建进程，使用队列进行通讯，可以这样： 1234567891011121314151617181920212223242526272829303132333435def put_data(queue): # 拼接数据 data = str(os.getpid()) + ' ' + str(time.time()) print('压入数据：', data) queue.put(data)def get_data(queue): data = queue.get() print('读取数据：', data)if __name__ == \"__main__\": # 创建队列 q = multiprocessing.Queue(3) # 创建5个进程用于写数据 pool1 = multiprocessing.Pool(4) pool1.map_async(put_data, [i for i in range(5)]) pool1.close() pool1.join() # 创建5个进程用于读数据 pool2 = multiprocessing.Pool(4) pool2.map_async(put_data, [i for i in range(5)]) pool2.close() pool2.join()# 运行结果如下：&gt;&gt;&gt; 压入数据： 16136 1573552887.7448432压入数据： 16136 1573552887.7468312压入数据： 16136 1573552887.74783压入数据： 16136 1573552887.7488291压入数据： 16136 1573552887.7718146压入数据： 17880 1573552888.1625717压入数据： 17880 1573552888.1655722压入数据： 17880 1573552888.1665695压入数据： 17880 1573552888.1795611压入数据： 19020 1573552888.1855621 9.8. 共享内存Python中提供了强大的Manager类，专门用于实现多进程之间的数据共享；Mangaer类支持的类型非常多，如：Value, Array, List, Dict, Queue, Lock等；Manager提供的数据不安全，需要通过Lock作处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import multiprocessingfrom ctypes import c_char_pdef run(v, s, a, l, d): print('子进程：', v.value) v.value += 10 print('子进程：', s.value) s.value = b'world' print('子进程：', a[0]) a[0] = 5 l.append('subprocess') d['name'] = 'xiaoming'if __name__ == \"__main__\": # 共享内存，可以共享不同类型的数据 server = multiprocessing.Manager() # 整数i, 小数f v = server.Value('i', 250) # 字符串 s = server.Value(c_char_p, b'hello') # 数组，相当于列表 a = server.Array('i', range(5)) # 列表 l = server.list() # 字典 d = server.dict() p = multiprocessing.Process(target=run, args=(v, s, a, l, d)) p.start() p.join() print('主进程：', v.value) print('主进程：', s.value) print('主进程：', a[0]) print('主进程：', l) print('主进程：', d)# 运行结果如下：&gt;&gt;&gt; 子进程： 250子进程： b'hello'子进程： 0主进程： 260主进程： b'world'主进程： 5主进程： ['subprocess']主进程： &#123;'name': 'xiaoming'&#125; 9.9. 多进程应用举例使用多进程实现拷贝文件夹，注意直接使用copy()效率比较低 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import multiprocessingimport osdef run(src, dst): src_fp = open(src, 'r') dst_fp = open(dst, 'w') content = src_fp.read(1024) while content: dst_fp.write(content) content = src_fp.read(1024) src_fp.close() dst_fp.close() print(src, '拷贝到', dst, '已完成')def copy(src, dst=None): if not dst: dst = f'&#123;src&#125;_副本' if not os.path.exists(src): print('源文件不存在！') return None if os.path.abspath(src) == os.path.abspath(dst): print('源文件与目标文件路径相同，无法进行拷贝！') return None if not os.path.exists(dst): os.makedirs(dst) record = [] src_dirs = os.listdir(src) for file in src_dirs: src_path = os.path.join(src, file) dst_path = os.path.join(dst, file) if os.path.isfile(src_path): p = multiprocessing.Process(target=run, args=(src_path, dst_path)) p.start() record.append(p) else: copy(src_path, dst_path) return recordif __name__ == \"__main__\": src = 'test' dst = '' record = copy(src, dst) if not record: print('拷贝异常...') else: for p in record: p.join() print('拷贝结束...')","link":"","tags":[{"name":"Python","slug":"Python","permalink":"https://lajos182.github.io/tags/Python/"},{"name":"进程","slug":"进程","permalink":"https://lajos182.github.io/tags/%E8%BF%9B%E7%A8%8B/"}]},{"title":"No.8 Python语言基础--面向对象","date":"2020-05-03T02:51:48.000Z","path":"2020/05/03/No-8-Python语言基础-面向对象/","text":"8.1. 类和对象的基本定义 类：具有相同特征（属性和行为）事物的抽象。其实是一种自定义的数据类型。 对象：某个类的具象。其实是某个类型的变量。 定义类需要使用关键字：class，也可以使用元类进行定义 类名：原则上只要符合标识符的命名规范即可，但是我们通常使用大驼峰风格(每个单词首字母大写)命名 不要忘记类名后面的冒号: 类的内容要进行缩进 行为(方法)：通过函数体现，与外面定义函数的方式相似，第一个参数默认是self 属性：通过变量体现，属性是动态添加的，因此在定义时可以不体现 成员访问：成员属性(对象.属性名)，成员方法(对象.方法名()) 示例：小明手里有两张牌，左手♥K，右手♠A，问：小明交换两手的牌后，手里分别是什么？ 思路： 先找到对象：小明、左手、♥K、♠A、右手 根据对象抽象出来对应的类：人、牌、手 写出对应的逻辑，反过来完善抽象出来的类 按照题目的要求创建对应的对象，调用相关的方法 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Poker(object): def __init__(self, color, number): self.color = color self.number = number def __str__(self): return f'&#123;self.color&#125;&#123;self.number&#125;'# 创建两张牌p1 = Poker('♥', 'K')p2 = Poker('♠', 'A') class Hand(object): def __init__(self, poker=None): self.poker = poker def hold_poker(self, poker): self.poker = poker# 创建左右手对象left_hand = Hand(p1)right_hand = Hand(p2)class Person(object): def __init__(self, name, left_hand, right_hand): self.name = name self.left_hand = left_hand self.right_hand = right_hand def show(self): print(f'&#123;self.name&#125;张开手', end=':') print(f'左手--&#123;self.left_hand.poker&#125;', end=',') print(f'右手--&#123;self.right_hand.poker&#125;') def swap(self): self.left_hand.poker, self.right_hand.poker = self.right_hand.poker, self.left_hand.poker print(f'&#123;self.name&#125;交换两手的牌')# 创建小明对象xiaoming = Person('小明', left_hand, right_hand)# 展示手里的牌xiaoming.show()# 交换两手牌xiaoming.swap()# 再次展示手里的牌xiaoming.show() self和cls区别： python并未对类中方法的第一个参数名字做限制，只不过是开发人员的习惯性用法。 self一般指类的实例，表示一个具体的实例本身，如果使用@staticmethod，就可以无视这个self，而将这个方法当成一个普通的函数使用。 cls表示这个类的本身 8.2. 常见的魔法函数魔法函数：在python中，有一些内置好的特定的方法，这些方法在进行特定的操作时会自动被调用，称之为魔法方法。 __init__()：初始化函数，在创建实例对象为其赋值时使用，在__new__之后，__init__必须至少有一个参数self，这个就是__new__返回的实例，__init__是在__new__的基础上可以完成一些其它初始化的动作，__init__不需要返回值。这种方法常被人称为构造方法。 __new__()：很多人认为__init__是类的构造函数，其实不太确切，__init__更多的是负责初始化操作，相当于一个项目中的配置文件，__new__才是真正的构造函数，创建并返回一个实例对象，如果__new__只调用了一次，就会得到一个对象。继承自object的新式类才有__new__这一魔法方法，__new__至少必须要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动提供，__new__必须要有返回值，返回实例化出来的实例（很重要），这点在自己实现__new__时要特别注意，可以return父类new出来的实例，或者直接是object的__new__出来的实例，若__new__没有正确返回当前类cls的实例，那__init__是不会被调用的，即使是父类的实例也不行。 创建对象的步骤： 123(1)首先调用__new__得到一个对象(2)调用__init__为对象添加属性(3)将对象赋值给变量 __init__和__new__两个魔法方法的例子： 1234567891011121314151617181920212223class A(object): passclass B(A): def __init__(self): print('__init__被调用......') def __new__(cls): print('__new__被调用......') print(id(cls)) # 此处采用了参数A而不是cls，__new__没有正确返回当前类cls的实例 return object.__new__(A)b = B()print(b, type(b))print(id(A), id(B))# 运行结果&gt;&gt;&gt; __new__被调用......&gt;&gt;&gt; 2219588983608&gt;&gt;&gt; &lt;__main__.A object at 0x00000204CA658400&gt; &lt;class '__main__.A'&gt;&gt;&gt;&gt; 2219588982664 2219588983608 从运行结果可以看出，__new__中的参数cls和B的id是相同的，表明__new__中默认的参数cls就是B类本身，而在return时，并没有正确返回当前类cls的实例，而是返回了其父类A的实例，因此__init__这一魔法方法并没有被调用，此时__new__虽然是写在B类中的，但其创建并返回的是一个A类的实例对象。 12345678910111213141516171819202122232425# 现在将return中的参数A变为cls，再来看一下运行结果：class A(object): passclass B(A): def __init__(self): print('__init__被调用......') def __new__(cls): print('__new__被调用......') print(id(cls)) # 此处采用了参数A而不是cls，__new__正确返回当前类cls的实例 return object.__new__(cls)b = B()print(b, type(b))print(id(A), id(B))# 运行结果&gt;&gt;&gt; __new__被调用......&gt;&gt;&gt; 2483180430712&gt;&gt;&gt; __init__被调用......&gt;&gt;&gt; &lt;__main__.B object at 0x0000024229AC93C8&gt; &lt;class '__main__.B'&gt;&gt;&gt;&gt; 2483180427880 2483180430712 可以看出，当__new__正确返回其当前类cls的实例对象时，__init__被调用了，此时创建并返回的是一个B类的实例对象。 __class__()：获取已知随想的类（对象.__class__） 12print(b.__class__)&gt;&gt;&gt; &lt;class '__main__.B'&gt; 当一个类中的某个成员属性是所有该类的对象的公共属性时，可以这样使用： 123456789101112131415class A(object): count = 0 def add_count(self): # self.__class__.count不再是单纯的某个对象私有的属性，而是类的所有实例对象的共有属性,它相当于self.A.count self.__class__.count += 1 # self.count += 1a = A()a.add_count()print('*********a***********', a.count)&gt;&gt;&gt; *********a*********** 1b = A()b.add_count()print('*********b***********', b.count)&gt;&gt;&gt; *********b*********** 2 __slots__: 用来限制实例属性 12345678910class Student(object): __slots__ = ('name', 'age')&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.name = 'Michael&gt;&gt;&gt; s.age = 20&gt;&gt;&gt; s.score = 80Traceback (most recent call last):File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'Student' object has no attribute 'score' __str__()：该函数要求返回一个字符串，当实例对象作为print参数打印时会打印该字符串。当打印一个类时，print首先调用的时类里面定义的__str__ 12345678910111213class A(object): def __init__(self, attr): self.attr = attr def __str__(self): return f'a的属性是&#123;self.attr&#125;'a = A('name')print(a)&gt;&gt;&gt; a的属性是nameprint(A)&gt;&gt;&gt; &lt;class '__main__.A'&gt; __repr__()：是给机器用的，在Python解释器里面直接敲对象名再回车后调用的方法。在没有str时就相当于它本身的作用 __del__()：对象在程序运行结束之后进行垃圾回收的时候调用这个方法，来释放资源。此时，此方法是被自动调用的。总而言之，__del__魔法方法是在对象没有变量再引用，其引用计数减为0，进行垃圾回收的时候自动调用的。 1234567891011121314151617181920212223242526class A(object): num_count = 0 # 共有属性 def __init__(self, name): self.name = name A.num_count += 1 print(name, A.num_count) def __del__(self): A.num_count -= 1 print('Del', self.name, A.num_count) def test(self): print('aaa')aa = A('hello')bb = A('world')cc = A('!!!!!')print('over')&gt;&gt;&gt; hello 1world 2!!!!! 3overDel hello 2Del world 1Del !!!!! 0 __delattr__()：删除一个对象的属性时调用 __getattr__()：当访问不存在的对象属性时，系统会自动调用 __getattribute__()：访问存在的属性时调用（先调用该方法，查看是否存在该属性，若不存在，接着去调用__getattr__） __setattr__()：设置成员属性时，系统会自动调用 12345678910111213141516171819202122232425262728293031class A(object): def __getattr__(self, item): print('访问不存在属性时调用__getattr__') try: return item except KeyError: raise AttributeError(f\"'Dict' object has no attribute &#123;item&#125;\") def __getattribute__(self, item): print('访问存在属性时调用__getattribute__') return object.__getattribute__(self, item) # 非绑定方法要显式传递self def __setattr__(self, item, value): print('设置对象成员属性的时候，自动调用__setattr__') self.__dict__[item] = value def __delattr__(self, item): print('销毁对象成员属性的时候，自动调用__delattr__') print('del', item)a = A()a.name = 'xiaoming'&gt;&gt;&gt; 设置对象成员属性的时候，自动调用__setattr__访问存在属性时调用__getattribute__print(a.age)&gt;&gt;&gt; 访问存在属性时调用__getattribute__访问不存在属性时调用__getattr__del a.name&gt;&gt;&gt; 销毁对象成员属性的时候，自动调用__delattr__del name __setitem__()：当对对象按照字典设置键值对时，会自动触发该方法 __getitem__()：当对对象按照字典操作根据键获取值时，会自动触发该方法 __delitem__()：当做字典操作，删除键值对时，自动触发该方法 12345678910111213141516171819202122class A(object): def __setitem__(self, key, value): print('调用了__setitem__方法') self.__dict__[key] = value def __getitem__(self, item): print('调用了__getitem__方法') return self.__dict__[item] def __delitem__(self, key): print('调用了__delitem__方法') del self.__dict__[key]a = A()a['name'] = name&gt;&gt;&gt; '调用了__setitem__方法'print(a['name'])&gt;&gt;&gt; '调用了__getitem__方法'namedel a['name']&gt;&gt;&gt; '调用了__delitem__方法' __iter__()：只要定义了__iter__()方法对象，就可以使用迭代器访问，这意味着，我们可以迭代我们自己定义的对象。 12345678910111213141516class A(object): def __init__(self): self._obj = [] def __iter__(self): return iter(self._obj) def add(self, obj): self._obj.append(obj)a = A()a.add(1)a.add(2)for i in a: print(i) __call__()：当实例被当做函数进行调用时会触发 1234567891011class A(object): def __init__(self): self.name = 'xiaoming' def __call__(self, age): return f'I am &#123;self.name&#125;, my age is &#123;age&#125; years old!'a = A()print(a(18))&gt;&gt;&gt; I am xiaoming, my age is 18 years old! __len__()：len调用后会调用对象的__len__函数，我们可以为其定制输出 1234567891011class A(object): def __init__(self, array): self.array = array def __len__(self): return len(self.array) + 100a = A([1, 2, 3, 4, 5])print(len(a))&gt;&gt;&gt; 105 8.3. 枚举类的使用 当我们需要定义常量时，通常使用大写变量通过整数来定义，例如月份，好处时简单，缺点是类型是int，并且仍然是变量。 123456JAN = 1FEB = 2MAR = 3...NOV = 11DEC = 12 更好的办法是为这样的枚举类型定义一个class类型，然后每个常量都是class的一个唯一实例。Python提供了Enum类来实现这个功能: 1234567from enum import EnumMonth = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))# 这样我们就获得了Month类型的枚举类，可以直接使用Month.Jan来引用一个常量，或者枚举它的所有成员：for name, member in Month.__members__.items(): print(name, '=&gt;', member, ',', member.value) 自定义枚举类：更精确的控制枚举类型，可以从Enum派生出自定义类,使用@unique装饰器可以帮助我们检查保证没有重复值 1234567891011121314151617181920212223242526272829303132333435363738394041424344from enum import Enum, unique@uniqueclass Weekday(Enum): Sun = 0 # Sun的value被设定为0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6# 访问这些枚举类型的方法：&gt;&gt;&gt; day1 = Weekday.Mon&gt;&gt;&gt; print(day1)Weekday.Mon&gt;&gt;&gt; print(Weekday.Tue)Weekday.Tue&gt;&gt;&gt; print(Weekday['Tue'])Weekday.Tue&gt;&gt;&gt; print(Weekday.Tue.value)2&gt;&gt;&gt; print(day1 == Weekday.Mon)True&gt;&gt;&gt; print(day1 == Weekday.Tue)False&gt;&gt;&gt; print(Weekday(1))Weekday.Mon&gt;&gt;&gt; print(day1 == Weekday(1))True&gt;&gt;&gt; Weekday(7)Traceback (most recent call last): ...ValueError: 7 is not a valid Weekday&gt;&gt;&gt; for name, member in Weekday.__members__.items():... print(name, '=&gt;', member)...Sun =&gt; Weekday.SunMon =&gt; Weekday.MonTue =&gt; Weekday.TueWed =&gt; Weekday.WedThu =&gt; Weekday.ThuFri =&gt; Weekday.FriSat =&gt; Weekday.Sat 枚举类的使用 1234567891011121314151617from enum import Enum, uniqueclass Gender(Enum): Male = 0 Female = 1class Student(object): def __init__(self, name, gender): self.name = name self.gender = gender# 测试mary = Student('Mary', name, Gender.Female):if mary.gender == Gender.Female: print('测试通过')else： print('测试失败') 8.4. 类的继承 继承：父类的属性和方法子类可以直接拥有的称为继承。 12345678910111213141516171819class Animal(object): def __init__(self, name): self.name = name def run(self): print('动物一般都喜欢跑！')class Dog(Animal): passd = Dog('wangcai')# 直接继承父类的属性print(d.name)# 直接拥有父类的方法d.run()&gt;&gt;&gt; wangcai动物一般都喜欢跑！ 派生：子类在父类的基础上衍生出来的新的特征(属性和方法)。 1234567891011121314151617181920class Animal(object): def __init__(self, name): self.name = name def run(self): print('动物一般都喜欢跑！')class Rabbit(Animal): # 添加方法 def eat(self): print('爱吃萝卜和青菜！')rabbit = Rabbit('xiaobai')rabbit.eat()&gt;&gt;&gt; 爱吃萝卜和青菜！# 添加属性rabbit.color = 'white'print(rabbit.color)&gt;&gt;&gt; white 重写：父类的方法完全不合适，子类需要全部的覆盖。或者是父类的方法合适，但需要完善。 123456789101112131415161718192021222324252627class Animal(object): def run(self): print('动物一般都喜欢跑！') def eat(self): print('小动物也是一天三顿！')class Cat(Animal): # 当父类的方法完全不合适时，可以覆盖重写 def run(self): print('喜欢走猫步！') # 父类的方法合适，但是子类需要添加内容完善功能 def eat(self): # 调用父类方法，不建议使用 # Animal.eat(self) # super(Cat, self).eat() # 类名及self可以不传 super().eat() print('最喜欢吃鱼！')jerry = Cat()jerry.run()&gt;&gt;&gt; 喜欢走猫步！jerry.eat()&gt;&gt;&gt; 小动物也是一天三顿！最喜欢吃鱼！ 8.5. 多继承 多继承：继承多个父类，会涉及到查找顺序(MRO)、重复调用(钻石继承，也叫菱形继承问题)等。 123456789101112131415161718192021222324252627282930313233343536373839class Father(object): def __init__(self, money): self.money = money def play(self): print('play basketball') def eat(self): print('喜欢吃红烧肉！')class Mother(object): def __init__(self, face_value): self.face_value = face_value def makeup(self): print('like make up') def eat(self): print('喜欢吃饺子！')class Son(Father, Mother): def __init__(self, money, face_value, hobby): # 多继承时无法使用super()，因为super()只可以再单继承中使用，当然子类也可以扩展自己的属性 Father.__init__(self, money) Mother.__init__(self, face_value) self.hobby = hobbyson = Son(500, 100, 'IT')print(son.money)&gt;&gt;&gt; 500print(son.face_value)&gt;&gt;&gt; 100# eat继承的父类都有该方法，会根据继承的顺序谁在前继承谁son.eat()&gt;&gt;&gt; 喜欢吃红烧肉！son.makeup()&gt;&gt;&gt; like make upson.play()&gt;&gt;&gt; play basketball MRO即method resolution order，用于判断子类调用的属性来自于哪个父类。在Python2.3之前，MRO是基于深度优先算法的，自2.3开始使用C3算法，定义类时需要继承object，这样的类称为新式类，否则为旧式类。案例可查看https://www.lajos.top/2020/04/27/No-1-Python%E7%AE%80%E4%BB%8B%E4%B8%8E%E7%89%88%E6%9C%AC%E4%BB%8B%E7%BB%8D/ 8.6. 多态性 多态：一种食物的多种形态。 案例： 如果要定义两个类(猫和老鼠)，他们分别都有name属性和eat方法，代码实现： 1234567891011121314151617class Cat(object): def __init__(self, name): self.name = name def eat(self): print(f'&#123;self.name&#125;在吃！') class Mouse(object): def __init__(self, name): self.name = name def eat(self): print(f'&#123;self.name&#125;在吃！')tom = Cat('tom')jerry = Mouse('jerry')tom.eat()&gt;&gt;&gt; tom在吃！jerry.eat()&gt;&gt;&gt; jerry在吃！ 如果有100种动物，他们都有name属性和eat方法，当然不需要这样写，就把这些动物都继承自一个基类。(如果一种植物也有这个属性和方法时，也可以继承自这个基类，这就是鸭子模型)。 12345678910111213141516171819class Animal(object): def __init__(self, name): self.name = name def eat(self): print(f'&#123;self.name&#125;在吃！') class Cat(Animal): def __init__(self, name): return super(Cat, self).__init__(name)class Mouse(Animal): def __init__(self, name): return super().__init__(name)tom = Cat('tom')jerry = Mouse('jerry')tom.eat()&gt;&gt;&gt; tom在吃！jerry.eat()&gt;&gt;&gt; jerry在吃！ 如果人要给100种动物喂食物，如何实现呢？ 123456789101112131415161718class Person(object): ''' def feedCat(self, cat): print('给你食物！') cat.eat() def feedMouse(self, mouse): print('给你食物！') mouse.eat() ''' # 只需要写一种方法，直接给这些动物继承的基类作为一个对象 def feed_animal(self, animal): print('给你食物') animal.eat()per = Person()# tom和jerry都继承自动物per.feed_animal(tom)per.feed_animal(jerry) 8.7. 封装性封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式。这样的好处：将变化隔离、便于使用、提高复用性、提高安全性。 封装原则：①将不需要对外提供的内容都隐藏起来；②把属性都隐藏，提供公共方法对其访问 广义的封装：把属性函数都放到类里。 侠义的封装：定义私有成员。 访问权限： 共有的：类中的普通属性和方法，默认都是公有的，可以在类的内部、外部、子类中使用 私有的：其实仅仅是一种变形操作，类中所有双下划线开头的名称(__x)都会自动变形成：_类名__x的形式。只能在本类的内部使用，不能再外部及子类中使用，且有些方法或属性 不希望被子类继承。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Person(object): def __init__(self, name, age): self.name = name # 在属性的前面添加两个'_'，外部访问，系统内部的除外 # 默认的属性名：__age =&gt; _Person__age self.__age = age def eat(self): print('民以食为天！') # 在方法的前面添加两个'_' def __inner(self): print('私有方法，不想让外部调用！') def test(self): # 在类的内部可以访问私有属性和方法 print(self.__age) self.__inner() self.eat()p = Person('老王', 50)# 默认所有的属性和方法都是公有的，就是在类的外面可以直接使用p.eat()&gt;&gt;&gt; 民以食为天！print(p.name)&gt;&gt;&gt; 老王# 以下两句会报错，提示没有相关的属性或方法# p.__inner()# print(p.__age)# 可以通过系统修改的名称找到，但是强烈建议不要这样使用print(p._Person__age)&gt;&gt;&gt; 18p._Person__inner()&gt;&gt;&gt; 私有方法，不想让外部调用！# 调用类的内部方法可以访问p.test()class Man(Person): def __inner(self): print('我想覆盖父类的属性，但没有办法！') def eat(self): print('我就是爱吃肉！')m = Man('lajos', 18)m.test()&gt;&gt;&gt; 18私有方法，不想让外部调用！ # 子类无法修改父类的方法我就是爱吃肉！ # 这个eat()不是私有方法，被覆盖 封装与扩展性 封装在于明确区分内外，使得类实现者可以修改封装内的东西而不影响外部调用者的代码；而外部使用者只需要知道一个接口(函数)，只要接口(函数)名、参数不变，合作基础使用者的代码永远无需改变。这就是提供一个良好的——或者说，只要接口这个基础约定不变，则代码改变不足为虑。 123456789101112131415161718192021222324252627282930313233# 类的设计者class Room(object): def __init__(self, name, owner, width, length, high): self.name = name self.owner = owner self.__width = width self.__length = length self.__high = high def tell_area(self): # 对外提供的接口，隐藏了内部的实现细节，此时我们想求的是面积 return self.__width * self.__lengthr1 = Room('卧室', 'egon', 20, 20, 20)print(r1.tell_area()) # 使用者调用接口tell_area&gt;&gt;&gt; 400# 类的设计者，轻松的扩展了功能，而类的使用者完全不需要改变自己的代码class Room: def __init__(self,name,owner,width,length,high): self.name=name self.owner=owner self.__width=width self.__length=length self.__high=high def tell_area(self): # 对外提供的接口，隐藏内部实现，此时我们想求的是体积,内部逻辑变了,只需求修该下列一行就可以很简答的实现,而且外部调用感知不到,仍然使用该方法，但是功能已经变了 return self.__width * self.__length * self.__high# 对于仍然在使用tell_area接口的人来说，根本无需改动自己的代码，就可以用上新功能prnit(r1.tell_area())&gt;&gt;&gt; 8000 8.8. 类属性类属性：定义类时，卸载类中，但是方法外的属性，通常放在类的开头位置。 123456789101112131415161718192021222324252627class Person(object): nation = 'China' def __init__(self, name): self.name = name self.nation = '中国'# 通过类名访问类属性print(Person.nation)# print(Person.name)# 通过对象也可一访问类属性，但是不建议# 当对象有同名的成员属性时，使用的就是成员属性p = Person('xiaoming')print(p.nation)# 也可以动态添加Person.hello = 'hello'print(Person.hello)# 特殊的类属性# 表示的类名字字符串，对象没有该属性print(Person.__name__)# 表示父类构成的元组，对象没有该属性print(Person.__bases__)# 存储类相关的信息print(Person.__dict__)print(p.__dict__) 8.9. 类方法(classmethod)类方法：定义时使用装饰器@classmethod，通过类名进行调用。可以创建对象或者简介的创建对象，对外提供简单易用的接口。传入的第一个参数为cls，是类本身，并且，类方法可以通过类直接调用，或通过实例直接调用。但无论哪种调用方式，最左侧传入的参数一定是类本身。 123456789class A(object): @classmethod def func(cls): print('我是类方法！')A.func() # 通过类直接调用a = A()a.func() # 通过实例对象调用 8.10. 静态方法(staticmethod)静态方法：使用装饰器@staticmethod进行装饰，定义是不需要第一个参数cls。调用过程中，无需进行实例化。 12345678class A(object): @staticmethod def func(): print('我是静态方法！')A.func() # 通过类直接调用a = A()a.func() # 通过实例对象调用 重点来了：Python中的实例方法、类方法和静态方法有什么区别？ 三种方法都可以通过对象进行调用，但类方法和静态方法无法访问对象属性，类方法通过对象调用获取的仍是类属性（并非对象属性）；普通方法无法通过类名调用，类方法和静态方法可以，但静态方法不能进行访问，仅仅只是通过传值得方式（与函数调用相同） 8.11. 属性函数属性函数：将方法当作属性一样调用，保护或处理特定属性。 12345678910111213141516171819202122232425262728293031import hashlibclass User(object): def __init__(self, username, password): self.username = username self.__password = password # 使用property装饰的方法，可以当作属性访问 # 可以保护特定的属性 @property def password(self): print('有人想直接获取密码！') # 可以给出警告提醒 return self.__password # 当设置password属性是，会自动调用该方法 @password.setter def password(self, password): print('注意了，有人想修改密码', password) # 可以对密码进行特定处理，然后保存 md = hashlib.md5() md.update(password.encode('utf-8')) self.__password = md.hexdigest()user = User('xiaoming', '123456')print(user.username)# 很多时候直接访问密码是不需要的，也是不安全的# 直接访问password属性，自动回调用使用property修饰后的password方法print(user.password)# 修改属性时会调用setter装饰的方法user.password = '654321' 8.12. 对象判断 判断一个对象是否可以像函数一样进行调用？ 123456789101112131415161718192021222324252627282930313233class A(object): def __call__(self, *args, **kwargs): print('++++')def test(): pass# 不能使用isinstance方法判断一个对象是否是函数# isinstance(test, function)# 打印时仍然是function类型# print(type(test))# 判断一个对象是否可以像函数一样调用print(callable(test))&gt;&gt;&gt; Truea = A()print(callable(a))&gt;&gt;&gt; True# 判断对象是否拥有call属性print(hasattr(test, 'call'))&gt;&gt;&gt; Falseprint(hasattr(a, 'call'))&gt;&gt;&gt; False# 判断是否是函数from inspect import isfunctionprint(isfunction(test))&gt;&gt;&gt; Trueprint(isfunction(a))&gt;&gt;&gt; False","link":"","tags":[{"name":"Python","slug":"Python","permalink":"https://lajos182.github.io/tags/Python/"},{"name":"类","slug":"类","permalink":"https://lajos182.github.io/tags/%E7%B1%BB/"},{"name":"对象","slug":"对象","permalink":"https://lajos182.github.io/tags/%E5%AF%B9%E8%B1%A1/"}]},{"title":"No.7 Python语言基础--异常处理","date":"2020-05-03T02:43:16.000Z","path":"2020/05/03/No-7-Python语言基础-异常处理/","text":"错误：程序运行前的语法问题，如：关键字、缩进、括号不成对等。 异常：在程序运行过程中出现的错误，如：变量未定义、除数为0、属性不存在等。 异常处理：异常处理可以认为是一种特殊的路程控制语句，可以提高代码的健壮性。 基本结构： 12345678910try: print('正常执行') # print(a) print(3/0)except Exception as e: # Exception是所有异常的基类，因此此处可以捕获所有异常 print('出现异常，进行处理') print(e)print('其他代码') 捕获多个异常： 12345678910try: # print(a) # print(3/0) fp = open('123.txt')except NameError as e: print('NameError:', e)except ZeroDivisionError as e: print('ZeroDivisionError:', e)except Exception as e: print('other:', e) 也可以对多种异常进行分组处理： 123456789try: # print(a) # print(3/0) fp = open('123.txt')except (NameError, ZeroDivisionError) as e: # 将特定的某些异常统一处理，写到元组中即可 print(e)except: print('其他异常') else和finally： 1234567891011try: print('正常执行') print(a)except: print('出现异常')else: # 出现异常就不执行了 print('正常结束')finally: # 无论有误异常都会执行 print('无论如何都执行') else：在没有异常的时候会执行，出现异常就不执行了 finally：无论是否有异常，都会执行 抛出异常raise： 123456789try: print('开始') # 根据代码逻辑的需要，手动抛出特定的异常 raise Exception('手动抛出异常') print('一切正常')except Exception as e: print('出现异常:', e)print('结束') 异常嵌套：try-except结构中嵌套try-except结构 1234567891011121314151617print('我要去上班，什么事情都不能阻止我上班的脚步')try: print('我准备骑电动车') raise Exception('昨天晚上那个缺德的家伙把我充电器给拔了，无法骑车') print('骑电动车提前到达公司')except Exception as e: print(e) try: print('我准备坐公交') raise Exception('等了20分钟一直没有公交车，果断放弃') print('坐公交准时到达公司') except Exception as e: print(e) print('我准备打车') print('打车还是快，一会就到公司了')print('热情满满的开始一天的工作') 自定义异常类：继承自异常的基类(Exception) 12345678910111213141516171819# 自定义异常类，名字通常以Exception结尾class MyException(Exception): def __init__(self, msg): self.msg = msg def __str__(self): # repr键变量转换成字符串，若本身是字符串则不必要 # return repr(self.msg) return self.msg def deal(self): print('异常已处理')try: print('正常执行') raise MyException('手动抛出定义异常')except MyException as e: print(e) e.deal() 特殊使用： 场景：做文件操作时，中间无论读写，也无论有误异常，最终一定要把文件关闭 with：使用with，不必再关系文件的关闭问题，with语句块结束后一定会确保文件关闭 12345678# fp = open('test.txt', 'rb')# # 各种读写操作# fp.close()# 使用with，无需关心文件的关闭问题with open('test.txt', 'rb') as fp: content = fp.read(5) print(content)","link":"","tags":[{"name":"Python","slug":"Python","permalink":"https://lajos182.github.io/tags/Python/"}]},{"title":"No.6 Python语言基础--IO编程","date":"2020-05-03T02:27:56.000Z","path":"2020/05/03/No-6-Python语言基础-IO编程/","text":"6.1. 文件读写读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。 读写文件前，我们先必须了解一下，在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。 字符编码 要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件, 遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，open()函数还接收一个errors参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略. 1234&gt;&gt;&gt; f = open('/Users/Administrator/gbk.txt', 'r', encoding='gbk')&gt;&gt;&gt; f.read()'测试'&gt;&gt;&gt; f = open('/Users/Administrator/gbk.txt', 'r', encoding='gbk', errors='ignore) 6.2. StringIO和BytesIO很多时候，数据读写不一定是文件，也可以在内存中读写。 StringIO：在内存中读写str 要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可： 1234567891011&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO()&gt;&gt;&gt; f.write('hello')5&gt;&gt;&gt; f.write(' ')1&gt;&gt;&gt; f.write('world!')6# `getvalue()`方法用于获取写入后的`str`&gt;&gt;&gt; print(f.getvalue())hello world! 要读取StringIO,可以用一个str初始化StringIO,然后像文件一样读取 1234567891011&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO('Hello!\\nHi!\\nGoodbye!')&gt;&gt;&gt; while True:... s = f.readline()... if s == '':... break... print(s.strip())...Hello!Hi!Goodbye! BytesIO：StringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。 BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes。请注意，写入的不是str，而是经过UTF-8编码的bytes。 123456&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO()&gt;&gt;&gt; f.write('中文'.encode('utf-8'))6&gt;&gt;&gt; print(f.getvalue())b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取。 1234&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO(b'\\xe4\\xb8\\xad\\xe6\\x96\\x87')&gt;&gt;&gt; f.read()b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 6.3. bytes函数的使用bytes函数返回一个新的bytes对象，该对象是一个0&lt;=x&lt;=256区间的整数不可变序列，它是bytearray的不可变版本。 bytes([source[, encoding[, errors]]])：返回一个新的bytes对象 如果source为整数，则返回一个长度为source的初始化数组 如果source为字符串，则按照指定的encoding将字符串转化为字节序列 如果source为可迭代类型，则元素必须[0, 255]中的整数 如果source为与buffer接口一致的对象，则此对象也可以被用于初始化bytearray 如果没有输入任何参数，默认就是初始化数组为0个元素 12345678910111213a = bytes([1, 2, 3, 4])print(a)print(type(a))&gt;&gt;&gt; b'\\x01\\x02\\x03\\x04'&lt;class 'bytes'&gt;a = [0xe0, 0xb9, 0x80, 0xe0, 0xb8, 0xa7, 0xe0, 0xb9, 0x87, 0xe0, 0xb8, 0x9a, 0xe0,0xb9, 0x84, 0xe0, 0xb8, 0x8b, 0xe0, 0xb8, 0x95, 0xe0, 0xb9, 0x8c]b = bytes(a)print(b)c = b.decode('utf-8')print(c)&gt;&gt;&gt; b'\\xe0\\xb9\\x80\\xe0\\xb8\\xa7\\xe0\\xb9\\x87\\xe0\\xb8\\x9a\\xe0\\xb9\\x84\\xe0\\xb8\\x8b\\xe0\\xb8\\x95\\xe0\\xb9\\x8c'เว็บไซต์ 6.4. 序列化 一般数据持久化存储采用三种方式：普通文件、数据库、序列化 pickle：pickle.dump(obj, fp)将对象存储到文件，pickle.load(fp)将文件转化为对象 123456789101112131415161718import pickleclass Person(object): def __init__(self, name, age): self.name = name self.age = age # 存储：对象=&gt;文件xiaoming = Person('xiaoming', 18)fp = open('text.txt', 'wb')pickle.dump(xiaoming, fp)print('对象数据存储完毕！')fp.close()# 读取：文件=&gt;对象fp = open('text.txt', 'rb')xiaoming = pickle.load(fp)print(xiaoming.name, xiaoming.age)fp.close() json：如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。 JSON类型 Python类型 {} dict [] list string str 1234.56 int或float true/false True/False null None Python内置的json模块提供了非常完善的Python对象到JSON格式的转换。我们先看看如何把Python对象变成一个JSON.dumps()方法返回一个str，内容就是标准的JSON。类似的，dump()方法可以直接把JSON写入一个file-like Object。 1234&gt;&gt;&gt; import json&gt;&gt;&gt; d = dict(name='Bob', age=20, score=88)&gt;&gt;&gt; json.dumps(d)'&#123;\"age\": 20, \"score\": 88, \"name\": \"Bob\"&#125;' 要把JSON反序列化为Python对象，用loads()或者对应的load()方法，前者把JSON的字符串反序列化，后者从file-like Object中读取字符串并反序列化。由于JSON标准规定JSON编码是UTF-8，所以我们总是能正确地在Python的str与JSON的字符串之间转换。 123&gt;&gt;&gt; json_str = '&#123;\"age\": 20, \"score\": 88, \"name\": \"Bob\"&#125;'&gt;&gt;&gt; json.loads(json_str)&#123;'age': 20, 'score': 88, 'name': 'Bob'&#125; Python的dict对象可以直接序列化为JSON的{}，不过，很多时候，我们更喜欢用class表示对象，比如定义Student类，然后序列化： 12345678910111213141516171819202122232425import jsonclass Student(object): def __init__(self, name, age, score): self.name = name self.age = age self.score = scores = Student('Bob', 20, 88)print(json.dumps(s))&gt;&gt;&gt; Traceback (most recent call last): ...TypeError: &lt;__main__.Student object at 0x10603cc50&gt; is not JSON serializable# 这是因为`dumps()`在序列化对象时，需要提供可选参数# 可选参数default就是把任意一个对象变成一个可序列为JSON的对象，我们只需要为Student专门写一个转换函数，再把函数传进去即可：def student_to_dict(std): return &#123; 'name': std.name, 'age': std.age, 'score': std.score &#125;&gt;&gt;&gt; print(json.dumps(s, default=student_to_dict))&#123;\"age\": 20, \"name\": \"Bob\", \"score\": 88&#125;&gt;&gt;&gt; print(json.dumps(s, default=lambda obj: obj.__dict__)) 同样的道理，如果我们要把JSON反序列化为一个Student对象实例，loads()方法首先转换出一个dict对象，然后，我们传入的object_hook函数负责把dict转换为Student实例： 12345def dict_to_student(d): return Student(d['name'], d['age'], d['score'])&gt;&gt;&gt; json_str = '&#123;\"age\": 20, \"score\": 88, \"name\": \"Bob\"&#125;'&gt;&gt;&gt; print(json.loads(json_str, object_hook=dict2student))&lt;__main__.Student object at 0x10cd3c190&gt;","link":"","tags":[{"name":"Python","slug":"Python","permalink":"https://lajos182.github.io/tags/Python/"},{"name":"IO","slug":"IO","permalink":"https://lajos182.github.io/tags/IO/"}]},{"title":"No.5 Python语言基础--正则","date":"2020-04-30T12:23:12.000Z","path":"2020/04/30/No-5-Python语言基础-正则/","text":"5.1. 正则基础应用场景：特定规律字符串的查找、替换、切割等；邮箱格式、url等的验证；爬虫项���，提取特定的有效内容；很多应用的配置文件 使用原则：只要能够通过自负床等相关函数能够解决的，就不要使用正则；正则的执行效率比较低，会降低代码的可读性； 基本使用：正则式通过re模块提供支持的，相关函数包括match、search、findall、compile match：从头惊醒匹配，知道就立即返回正则结果对象，没有就返回None search：匹配全部内容，任意位置，只要找到，立即返回正则结果对象，没有返回None findall：匹配所有内容，返回匹配结构组成的列表，没有返回None compile：根据字符串生成正则表达式的对象，用于特定正则匹配，通过match、search、findall 5.2. 正则规则 单个字符： 1234567891011121314普通字符：就是一对一的完全匹配[]：中间的任意一个字符 [a-z]：表示a到z的任意字符 [0-9]：表示0到9的任意字符 [^abc]：除abc之外的字符. ：匹配'\\n'以外的任意字符\\d：所有的数字字符，等价于[0-9]\\D：所有的非数字字符，等价于[^0-9]\\w：所有的数字、字母、中文、下划线等 (就是字的意思)\\W：\\w之外的所有字符\\s：所有的空白字符，如：空格、\\t、\\n、\\r\\S：\\s之外的所有字符\\b：词边界，如：开头、结尾、标点、空格等\\B：非词边界 次数控制： 123456*：前面的字符可以是任意次+：前面的字符至少出现一次?：至多一次，0次或1次&#123;m&#125;：匹配固定的m次&#123;m,&#125;：至少m次&#123;m,n&#125;：m到n次 正则的匹配默认是贪婪的 贪婪：最大限度的匹配，正则的匹配默认是贪婪的 非贪婪：只要满足匹配条件，能少匹配就少匹配，通常使用’?’取消贪婪 123456789101112import re# c = re.compile(r'a.*?c')c = re.compile(r'a.+?c')s = c.search('abcjsdhfkdkc')if s: print('ok') print(s.group())&gt;&gt;&gt; okabc 边界限定 12^：以指定内容开头$：以指定内容结尾 分组匹配 12|：表示或，具有最低的优先级()：用于表示一个整体，可以确定优先级 1234567891011import rec = re.compile(r'(\\d+)([a-z]+)(\\d+)')s = c.search('sda123ksdak456sdk')if s: print('ok') print(s.group()) //所有匹配的字符(即匹配正则表达式整体结果) print(s.group(0)) //与group()相同 print(s.group(1)) //列出第一个括号匹配的字符 print(s.group(2)) //列出第二个括号匹配部分 print(s.group(3)) //列出第三个括号匹配部分 print(s.groups()) //返回所有括号匹配的字符，以tuple格式 1234567891011121314import re# 正则中的\\1:表示前面第一个小阔号匹配的结果# c = re.compile(r'&lt;([a-z]+)&gt;&lt;([a-z]+)&gt;\\w*&lt;/\\2&gt;&lt;/\\1&gt;')# c = re.compile(r'&lt;(?P&lt;hello&gt;[a-z]+)&gt;&lt;(?P&lt;world&gt;[a-z]+)&gt;\\w*&lt;/\\2&gt;&lt;/\\1&gt;')# 可以给指定的分组起个名字c = re.compile(r'&lt;(?P&lt;hello&gt;[a-z]+)&gt;&lt;(?P&lt;world&gt;[a-z]+)&gt;\\w*&lt;/(?P=world)&gt;&lt;/(?P=hello)&gt;')s = c.search('xxx&lt;div&gt;&lt;a&gt;百度一下&lt;/a&gt;&lt;/div&gt;yyy')if s: print('ok') print(s) print(s.group()) 转义字符 1234在匹配所有正则中有特殊含义的字符时，都需要转义。正则字符串需要被处理两次，python中处理，正则解析时处理一次。通常在写正则字符串时，前面都加一个'r'，表示原始字符，让所有的字符失去意义。在匹配有如：'\\'的字符时，前面再添加一个'\\'就可以了，如果没有添加'r'，通常要写好几个。 5.3. 正则高阶 匹配模式 正则可以对匹配的模式做出整体的修饰处理，如忽略大小写等。 12345678910111213141516import re# 忽略大小写# c = re.compile(r'hello', re.I)# 多行匹配# c = re.compile(r'^hello', re.M)# 作为单行处理 或 让 . 匹配 '\\n'c = re.compile(r'&lt;div&gt;.*?&lt;/div&gt;', re.S)string = ''''&lt;div&gt;\\nhello\\n&lt;/div&gt;'''s = c.search(string)if s: print('ok') print(s.group()) 字符串切割split 某些情况下，无法通过字符串函数进行切割，可以使用正则的方式处理，如：按照数字切割。可使用split切割，返回一个列表 123456789import rec = re.compile(r'\\d')string = '正则1其实也不难2但是学完发现自己写不出来3是这样吧'ret = c.split(string, maxsplit=2)print(ret)print(type(ret))&gt;&gt;&gt; ['正则', '其实也不难', '但是学完发现自己写不出来3是这样吧']&lt;class 'list'&gt; 字符串替换sub 简单的替换可以自己处理，要是按照正则规律进行替换就要使用专用的函数sub处理。 123456import rec = re.compile(r'\\d')string = 'sa1erfewr2fsdfs3dfsd'ret = c.sub('***', string)print(ret)","link":"","tags":[{"name":"Python","slug":"Python","permalink":"https://lajos182.github.io/tags/Python/"},{"name":"正则","slug":"正则","permalink":"https://lajos182.github.io/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"No.4 Python语言基础--模块使用","date":"2020-04-29T14:04:41.000Z","path":"2020/04/29/No-4-Python语言基础-模块使用/","text":"模块：模块就像一个工具包一样，里面有很多工具(函数、类)，使用时需要通过import导入。 分类： ①标准库：random、sys、os、time； ②第三方：已经写好的特定功能的模块，你可以直接使用pip命令安装； ③自定义：自己写的 12345import random # 导入import random as rdm # 导入并起别名from time import sleep # 指定导入from time import sleep as sp # 指定导入并起别名from random import * # 模糊导入 自定义模块：新建一个文件，不与其他模块同名，该文件名就是模块，导入方式于官方的相同。文件名(模块名)就是命名空间，不同命名空间下的标识符可以同名，当使用几个模块中相同的（函数）标识符时，可以通过命名空间或起别名解决。 测试模块：当一个模块作为主模块运行时，__ name __的值为&#39;__ main __&#39;，当被其他模块导入使用时，值为模块名。 12if __name__ &#x3D;&#x3D; &#39;__main__&#39;: print(&#39;测试代码&#39;) 包：多个模块放在同一目录下，目录下有一个__ init __.py文件，这个目录就是一个包。一个目录要想成为一个包，必须包含一个__ init __.py文件，即使该文件为空(可以简化导入书写) 修改pip源： Windows：进入用户的家目录(在windows文件管理器中,输入%APPDATA%)，在该目录下新建pip文件夹，并创建pip.ini，然后添加对应的镜像源； Linux：进入用户的加目录(cd ~)，然后创建.pip文件夹(mkdir .pip)并创建pip.conf(touch pip.conf)文件，然后对应的镜像源； 国内常用的pip镜像 1234567891011清华：https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple阿里云：http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;中国科技大学 https:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple&#x2F;华中理工大学：http:&#x2F;&#x2F;pypi.hustunique.com&#x2F;山东理工大学：http:&#x2F;&#x2F;pypi.sdutlinux.org&#x2F; 豆瓣：http:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F; 使用方法： 123[global]index-url &#x3D; http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;trusted-host &#x3D; mirrors.aliyun.com pip命令：安装软件包，自动会安装相关的依赖 12345678安装软件包：pip install 包名卸载软件包：pip uninstall 包名列表显示包：pip list查看指定包：pip show 包检测哪些包需要更新：pip list --outdated升级包：pip install --upgrade 包名输出已安装的包列表：pip freeze &gt; requirements.txtpip帮助：pip help","link":"","tags":[{"name":"Python","slug":"Python","permalink":"https://lajos182.github.io/tags/Python/"}]},{"title":"No.3 Python语言基础--函数及其常用函数的使用","date":"2020-04-28T10:35:40.000Z","path":"2020/04/28/No-3-Python语言基础-函数及其常用函数的使用/","text":"3.1. 函数的基本定义函数：具有特定功能的一段代码。 函数的优点： 解决代码的重复书写问题 可以将功能的实现者和使用者分开，提高开发效率 增加的代码的可移植性 函数参数： 形参：形式参数，函数定义处的参数 实参：实际参数，函数调用处的参数 必传参数：也叫位置参数，前面定义的函数中使用的都是必传参数，调用时的形式必须要与定义的一致。 默认参数：也称关键字参数，就是有默认值的参数，必须放在最后 可变长度参数：函数调用时传递必定义时的参数要多，多出来的参数会保存在args和kwargs中 *args与**kwargs的区别： 用*args和**kwargs只是为了方便并没有强制使用它们。 *args接受多余的位置参数，转化程元组tuple形式，**kwargs接受N个关键字参数，转换成字典dict形式 *的特殊用法： 123456789101112131415161718def show(a, b): print(a, b) l = [1, 2] # 略显啰嗦 # show(l[0], l[1]) # 精简方法 show(*l) def show2(a='aa', b='bb'): print(a, b) d = &#123;'a':'apple', 'b':'banana'&#125; # show2(a=d['a'], b=d['b']) # 上面方式的简单书写方法 show2(**d) 位置参数：调用参数时比较灵活，加不加关键字都可以，但python3.8引入新的语法控制这种灵活性，&#39;/&#39;之前的参数必须不加关键字，&#39;*&#39;之后的参数必须加关键字，其他参数依旧随意。 1234567891011121314151617181920212223242526272829303132# python3.8之前定义函数def center(txt, border='=', width=50): return f'&#123;txt&#125;'.center(width, border)# 调用结果：&gt;&gt;&gt;center('python')'=========================python========================'&gt;&gt;&gt;center('python', '*', 10)'**python**'&gt;&gt;&gt;center('python', border='*', width=10)'**python**'&gt;&gt;&gt;center(txt='python', border='*', width=10)'**python**'# python3.8新特性：def center(txt, /, border='=', *, width=50): return f'&#123;txt&#125;'.center(width, border)# 调用结果&gt;&gt;&gt; center(txt = '中心',border='$',width = 10)Traceback (most recent call last): File \"&lt;pyshell#68&gt;\", line 1, in &lt;module&gt; center(txt = '中心',border='$',width = 10)TypeError: center() got some positional-only arguments passed as keyword arguments: 'txt'&gt;&gt;&gt;center( '中心','$', 10)Traceback (most recent call last): File \"&lt;pyshell#69&gt;\", line 1, in &lt;module&gt; center( '中心','$', 10)TypeError: center() takes from 1 to 2 positional arguments but 3 were given&gt;&gt;&gt; center('中心',border='$',width = 10)'$$$$中心$$$$'&gt;&gt;&gt; center('中心','$',width = 10)'$$$$中心$$$$' 3.2. 变量作用域（LEGB）LEGB规则：local &gt; enclosed&gt; global &gt; bulit-in （1）块级作用域：Python不存在块级作用域，下民的代码可以正常运行。 1234if True: name = 'xiaoming'print(name) （2）局部作用域：定义在函数内部的变量叫局部变量，只能在函数内部使用。 123456def test(): a = 1test()# 此处会报错，提示变量未定义# print(a) （3）全局作用域：定义在函数外部的变量叫全局变量，哪里都可以使用(但是不能修改，除非使用global) 12345678a = 10def test(): # 加上这句代码，就可以在函数内部修改全局变量 global a a = 1test()print(a) （4）闭包函数外的函数中： 1234567891011def wai(): age = 20 def nei(): # 使用外层函数的局部变量，加上nonlocal姐可以修改外部函数的局部变量 nonlocal age age = 30 print(age) nei() print(age) wai() 3.3. 内置函数、模块函数及基本数据结构函数 3.4. 匿名函数匿名函数lambda：就是没有名字的函数，使用lambda关键字定义。 特点： 以lambda开头 后面跟上该匿名函数的参数，多个参数使用逗号隔开 最后一个参数的后面跟上冒号’:’ 冒号的后面跟上一个表达式，这个表达式就是返回值，不需要使用return 3.5. 递归函数递归函数： 函数内部调用函数本身的函数叫递归函数 特点： 代码简洁 可读性差(不易理解) 瞬间占用内存较大，没有终止条件会立即崩溃 有些领域禁止使用(安全领域：汽车电子) 只有在不得不使用的时候再使用(目录操作) 斐波那契数列(1,1,2,3,5,8,13,21,34,…) 123456def fibonacci(n): if n == 1 or n == 2: return 1 return fibonacci(n-2) + fibonacci(n-1)print(fibonacci(6)) 3.6. 闭包与装饰器闭包：外部函数中定义一个内部函数，内部函数中使用了外部函数的变量，外部函数将内部函数作为返回值返回。提高了代码的可重复使用性. 1234567def wai(n): def nei(): return n*n return neif1 = wai(3)print(f1()) 装饰器：本质就是一个函数，该函数接受一个函数作为参数，返回一个闭包，而且闭包中执行传递进来的函数，闭包中可以在函数执行的前后添加额外的功能。 装饰器的作用就是为已经存在的对象添加额外的功能。 12345678910def zhuangshiqi(func): def wrapper(*args, **kwargs): return func(*args, **kwargs) + 10 return wrapper@zhuangshiqidef pingfang(n): return n * nprint(pingfang(4)) 3.7. 迭代器与生成器 迭代器(Iterator)：可以使用for-in进行遍历，并且可以使用next依次获取元素的对象。 可以使用isinstance判断是否是迭代器。 1234from collections import Iteratorl = (i for i in range(10))print(isinstance(l, Iterator)) 生成器(generator)：为了解决内存突然变大的问题，Python引入了生成器。它是一种他叔的迭代器。 产生条件： 将列表生成式中的[]改为() 123456# 数据量特别大时，会造成内存占用突然增大# l2 = [i for i in range(10000)]# 生成器l2 = (i for i in range(2))# 使用next获取生成器中值，一次一个，遍历结束会报错StopIterationprint(next(l2)) 通常在函数中使用yield关键字 123def test(n): for i in range(1, n+1): yield i 特性 可以使用next获取数据，一次一个，结束时会报错 只能遍历一遍 可以转换为列表 可以使用for-in遍历 3.8. 高级函数 可迭代对象：可以使用for-in遍历的对象，我们都称之为可迭代对象。字符串、列表、元组、集合、字典等都不是迭代器，他们都是可迭代对象。 可以使用isinstance判断是否是可迭代对象： 123from collections import Iterableprint(isinstance(l, Iterable))print(isinstance(lt, Iterable)) 高级函数map：格式map(func, lt)，接受两个参数，一个函数和一个可迭代对象，返回一个生成器，将func依次作用于lt 12l = [1,2,3,4,5]m = map(lambda x:x*x, l) # 迭代器 高级函数filter：格式filter(funct, lt)，使用func依次作用于每个元素，处理结果为True保留下来。 123456l = [1,2,3,4,5]# 提取偶数f = filter(lambda x:x%2==0, l)print(list(f)) 高级函数reduce：格式reduce(func, lt), 接受两个参数，一个函数和一个可迭代对象，首先取两个元素，使用func处理，结果和第三个元素继续使用func处理，直到结束，返回处理的结果。 123456789from functools import reducel = [1,2,3,4,5]# 求和print(reduce(lambda x, y:x+y, l))# 转换为12345print(reduce(lambda x, y:x*10+y, l)) 高级函数sorted：格式sorted(func, lt), 内建函数，用于对可迭代快递的每个元素进行排序，生成新的对象。 123456789l = [ &#123;'name':'xiaowang', 'age':18,'height':150&#125;, &#123;'name':'xiaogang', 'age':20,'height':140&#125;, &#123;'name':'xiaohong', 'age':19,'height':145&#125;,]l2 = sorted(l, key=lambda x:x['age'], reverse=True)print(l2) 注意：sort也可用来排序，它是list的排序方法，用于对列表的成员进行排序，而且改变的是原列表。 3.9. 匿名、递归、闭包、高级函数总结 3.10.目录管理与文件操作相关模块函数 目录管理(os) 12345678910111213141516171819202122232425262728293031# system, 执行系统命令os.system('cls')# name, 获取操作系统名称，nt代表Windows, posix代表unixprint(os.name)# environ, 获取环境变量os.environ.get('path')os.environ.get(['path'])os.getenv('path')# getcwd, 获取当前工作目录os.getcwd()# mkdir, 创建目录，该方法创建中间目录会报错os.mkdir('hello')# makedirs, 创建目录，会创建中间目录os.makedirs('a/b/c')# rmdir, 删除目录，只能删除空目录os.rmdir('a')# rename, 修改文件名(可以是目录)os.rename('a', 'c')# stat, 查看文件信息os.stat('123.py')# listdir, 列出直接子文件os.listdir('c') path函数 123456789101112131415161718192021222324252627from os import path# 提取文件后缀（切割文件名与后缀）name, ext = path.splitext('789.py')print(name, ext)# 提取目录名（最后一个目录分隔符的前面内容）print(path.dirname('123/456/789.py'))# 提取文件名(包括后缀)print(path.basename('123/456/789.py'))# 切割文件名和目录print(path.split('123/456/789.py'))# 判断文件是否存在（可以是目录）print(path.exists('123.py'))# 判断是否是目录文件print(path.isdir('c'))# 判断是否是普通文件print(path.isfile('123.py'))# 获取普通文件大小print(path.getsize('01-os.py'))# 不可以获取目录大小，始终是0print(path.getsize('c')) 文件管理 打开文件（open）：fp = open(&#39;00-test.txt&#39;, &#39;r&#39;) 1234567891011121314151617181920# 参数1：文件路径名；参数2：打开方式；参数3：编码格式，一般不用指定，系统会自动识别处理# 打开方式：r：只读方式，文件不存在会报错w：只写方式，文件不存在创建文件，文件存在清空内容a：追加方式，文件不存在则创建，文件存在直接打开(不会清空内容)，只能向最后追加内容r+：在r方式下添加写的功能w+：在w方式下添加读的功能a+：在a方式下添加读的功能在上面的模式上添加b，表示二进制方式打开：rb、wb、ab、rb+、wb+、ab+1.文件的读写数据全部是bytes类型，没有添加b的方式全部是str类型# 编码方式ascii：美国信息交换标准代码ansi：扩展的asciigb2312：中国的ansigbk：扩展的gb2312unicode：是一套理论，实现方式不限utf-8：可变长度的unicode实现，对中文的支持比较友好 关闭文件（close）：fp.close() 文件读写 12345678910111213141516# 读取指定长度内容# ret = fp.read(3)# 写入内容fp.write('hello')# 读取一行，包括换行符print(fp.readline())# 读取所有行，返回一个列表print(fp.readlines())# 是否可读print(fp.readable())# 是否可写print(fp.writable()) read、readline和readlines的区别，如何读取大文件 read()方法：读取整个文件，将文件内容放到一个字符串变量中，如果需要对文件按行进行处理，则不可用该方法。如果文件大于可用内存(好几个G的)，不可能使用这种处理，系统会报错：MemoryError readline()方法： 读取下一行，每只读取文件的一行，通常也是读取到的一行内容放到一个字符串变量中，返回str类型。内存不够时使用，一般不太用。 readlines()方法：读取整个文件所有行，保存在一个列表(list)变量中，每行作为一个元素，但读取大文件会比较占内存。 大文件读取数据：处理大文件是很容易想到的就是将大文件分割成若干小文件处理，处理完每个小文件后释放该部分内存（分块读取）。这里用了iter &amp; yield 分块读取（yield）：将大文件分割成若干小文件处理，处理完每个小文件后释放该部分内存 1234567891011121314151617# 分块读取def read_chunk(file_name, trunk_size): fp = open(file_name, 'rb') # 创建文件对象，也是一个可迭代对象 # while True: # content = fp.read(trunk_size) # if not content: # break # yield content content = fp.read(trunk_size) while content: content = fp.read(trunk_size) yield content if __name__ == '__main__': file_name = r'F:\\AngularJS学习资料\\第一章 AngularJS教程.md' for i in read_chunk(file_name, 50): print(i) 使用with（操作可迭代对象）：对可迭代对象 fp，进行迭代遍历：for line in fp，会自动地使用缓冲IO（buffered IO）以及内存管理，而不必担心任何大文件的问题。 123with open(r'F:\\AngularJS学习资料\\第一章 AngularJS教程.md', 'rb') as fp: for line in fp: print(line) 文件指针 12345678# 返回文件指针的操作位置print(fp.tell())# 设置偏移# 参数1：偏移量# 参数2：参考位置，0：开头，1：当前，2：末尾# 定位到末尾fp.seek(0, 2) 带b的方式seek没有异常；不带b的时候，相对于当前位置无法偏移，相对于末尾只能偏移0 文件删除 12import osos.remove('02-test.py') 文件高级操作shutil: copyfileobj(fsrc, fdst, length=16*1024)：将fsrc文件内容复制至fdst文件，length为fsrc每次读取的长度，用做缓冲区大小 1234import shutilfp1 = open('file.txt', 'r')fp2 = open('file_copy.txt', 'a+')shutil.copyfileobj(fp1, fp2, length=1024) copyfile(src, dst)：将src文件内容复制至dst文件，若dst文件不存在，将会生成一个dst文件；若存在将会被覆盖 12import shutilshutil.copyfile(\"file.txt\",\"file_copy.txt\") copymode(src, dst, follow_symlinks=True)：将src文件权限复制至dst文件，文件内容，所有者和组不受影响。dst路径必须是真实的路径，并且文件必须存在，否则将会报文件找不到错误。follow_symlinks为Python3新增参数，设置为False时，src, dst皆为软连接，可以复制软连接权限，如果设置为True，则当成普通文件复制权限。默认为True。 12import shutilshutil.copymode(\"file.txt\",\"file_copy.txt\") copystat(src, dst, follow_symlinks=True)：将权限，上次访问时间，上次修改时间以及src的标志复制到dst。文件内容，所有者和组不受影响。follow_symlinks设置为False时，src, dst皆为软连接，可以复制软连接权限、上次访问时间，上次修改时间以及src的标志，如果设置为True，则当成普通文件复制权限。默认为True。 12import shutilshutil.copystat(\"file.txt\",\"file_copy.txt\") copy(src, dst, follow_symlinks=True)： 将文件src复制至dst。dst可以是个目录，会在该目录下创建与src同名的文件，若该目录下存在同名文件，将会报错提示已经存在同名文件。权限会被一并复制。本质是先后调用了copyfile与copymode而已。follow_symlinks和上面作用相同。 1234improt shutil,osshutil.copy(\"file.txt\",\"file_copy.txt\")# 或者shutil.copy(\"file.txt\",os.path.join(os.getcwd(),\"copy\")) copy2(src, dst, follow_symlinks=True)：将文件src复制至dst。dst可以是个目录，会在该目录下创建与src同名的文件，若该目录下存在同名文件，将会报错提示已经存在同名文件。权限、上次访问时间、上次修改时间和src的标志会一并复制至dst。本质是先后调用了copyfile与copystat方法而已。follow_symlinks和上面作用相同。 1234improt shutil,osshutil.copy2(\"file.txt\",\"file_copy.txt\")# 或者shutil.copy2(\"file.txt\",os.path.join(os.getcwd(),\"copy\")) ignore_patterns(*patterns)：忽略模式，用于配合copytree()方法，传递文件将会被忽略，不会被拷贝。patterns是文件名称、元组。 **`copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2, ignore_dangling_symlinks=False`)`**：拷贝文档树，将`src`文件夹里的所有内容拷贝至`dst`文件夹，文件夹不存在会自动创建。`symlinks`代表是否复制软连接，`True`复制软连接，`False`不复制，软连接会被当成文件复制过来，默认`False`。`ignore`为忽略模式，可传入`ignore_patterns()`。`copy_function`为拷贝文件的方式，可传入一个可执行的处理函数，默认为`copy2`，`ignore_dangling_symlinks`设置为`False`，拷贝指向文件已删除的软连接时，将会报错，如果想消除这个异常，可以设置此值为True，默认为`False`。123456import shutil,osfolder1 = os.path.join(os.getcwd(),\"aaa\")# bbb与ccc文件夹都可以不存在,会自动创建folder2 = os.path.join(os.getcwd(),\"bbb\",\"ccc\")# 将\"abc.txt\",\"bcd.txt\"忽略，不复制shutil.copytree(folder1,folder2,ignore=shutil.ignore_patterns(\"abc.txt\",\"bcd.txt\") rmtree(path, ignore_errors=False, onerror=None)：移除文档树，将文件夹目录删除。ignore_errors代表是否忽略错误，默认False，onerror定义错误处理函数，需传递一个可执行的处理函数，该处理函数接收三个参数：函数、路径和excinfo 123import shutil,osfolder1 = os.path.join(os.getcwd(),\"aaa\")shutil.rmtree(folder1) move(src, dst, copy_function=copy2)：将src移动至dst目录下。若dst目录不存在，则效果等同于src改名为dst。若dst目录存在，将会把src文件夹的所有内容移动至该目录下面。copy_function为拷贝文件的方式，可传入一个可执行的处理函数，默认为copy2。 12345678910111213import shutil,os# 示例一，将src文件夹移动至dst文件夹下面，如果bbb文件夹不存在，则变成了重命名操作folder1 = os.path.join(os.getcwd(),\"aaa\")folder2 = os.path.join(os.getcwd(),\"bbb\")shutil.move(folder1, folder2)# 示例二，将src文件移动至dst文件夹下面，如果bbb文件夹不存在，则变成了重命名操作file1 = os.path.join(os.getcwd(),\"aaa.txt\")folder2 = os.path.join(os.getcwd(),\"bbb\")shutil.move(file1, folder2)# 示例三，将src文件重命名为dst文件(dst文件存在，将会覆盖)file1 = os.path.join(os.getcwd(),\"aaa.txt\")file2 = os.path.join(os.getcwd(),\"bbb.txt\")shutil.move(file1, file2) disk_usage(path)：获取当前目录所在硬盘使用情况。path表示文件夹或文件路径，windows中必须是文件夹路径，linux中可以是文件路径和文件夹路径。 1234import shutil.ospath = os.path.join(os.getcwd(),\"aaa\")info = shutil.disk_usage(path)print(info) # usage(total=95089164288, used=7953104896, free=87136059392) chown(path, user=None, group=None)：修改路径指向的文件或文件夹的所有者或分组。 123import shutil,ospath = os.path.join(os.getcwd(),\"file.txt\")shutil.chown(path, user=\"root\", group=\"root\") which(cmd, mode=os.F_OK | os.X_OK, path=None)： 获取给定的cmd命令的可执行文件的路径。 12import shutilprint(shutil.which('pip')) # D:\\Python\\Python36\\Scripts\\pip.EXE make_archive(base_name, format, root_dir, …)：生成压缩文件。base_name指压缩文件的文件名，不允许有扩展名(因为会根据压缩格式生成相应的扩展名)，format表示压缩格式，root_dir表示将指定文件夹进行压缩。 123456import shutil,osbase_name = os.path.join(os.getcwd(),\"aaa\")format = \"zip\"root_dir = os.path.join(os.getcwd(),\"aaa\")# 将会root_dir文件夹下的内容进行压缩，生成一个aaa.zip文件shutil.make_archive(base_name, format, root_dir) get_archive_formats()：获取支持的压缩文件格式。目前支持的有：tar、zip、gztar、bztar。在Python3还多支持一种格式xztar。 unpack_archive(filename, extract_dir=None, format=None)：解压操作，extract_dir解压至的文件夹路径，文件夹可以不存在，会自动生成。format解压格式，默认为None，会根据扩展名自动选择解压格式。 1234import shutil,oszip_path = os.path.join(os.getcwd(),\"aaa.zip\")extract_dir = os.path.join(os.getcwd(),\"aaa\")shutil.unpack_archive(zip_path, extract_dir) get_unpack_formats()：获取支持的解压文件格式。目前支持的有：tar、zip、gztar、bztar和xztar。 经典练习 实现一个拷贝文件的功能，提醒：要考虑超大文件问题，如:依次读取1024字节，循环读取 123456789101112131415161718192021import osdef copy_file(source, target): if not os.path.exists(source): print('源文件不存在！') return if os.path.isdir(source): print('源文件是目录文件，无法拷贝！') return if os.path.abspath(source) == os.path.abspath(target): print('复制的地址与源文件相同，无法进行复制！') return if os.path.isdir(target): target = os.path.join(target, os.path.basename(source)) source_fp = open(source, 'rb') target_fp = open(target, 'wb') content = source_fp.read(1024) while content: target_fp.write(content) content = source_fp.read(1024) source_fp.close() target_fp.close() 递归拷贝一个文件夹 1234567891011121314151617181920212223def copy_dir(source, target): if not os.path.exists(source): print('原文件不存在！') return if os.path.isfile(target): print('源文件不是目录文件！') if os.path.isfile(target): print('目标地址不是目录，无法进行拷贝') return if os.path.abspath(source) == os.path.abspath(target): print('复制的地址与源文件相同，无法进行复制') return if not os.path.exists(target): os.makedirs(target) source_list = os.listdir(source) for item in source_list: source_name = os.path.join(source, item) target_name = os.path.join(target, item) if os.path.isfile(source_name): copy_file(source_name, target_name) # 拷贝单个文件 else: copy_dir(source_name, target_name) # 递归拷贝 copy_dir('a', 'b') 递归删除一个文件夹(或文件) 12345678910111213141516import osdef delete_dir(source): if not os.path.exists(source): print('要删除的文件不存在！') return if os.path.isfile(source): os.remove(source) source_list = os.listdir(source) for item in source_list: source_path = os.path.join(source, item) if os.path.isfile(source_path): os.remove(source_path) else: delete_dir(source_path) os.rmdir(source)delete_dir('../ccc') 递归统计一个文件夹的大小 12345678910111213141516171819import osdef get_size(source): size = 0 if not os.path.exists(source): print('当前文件(夹)不存在！') return if os.path.isfile(source): size += os.path.getsize(source) return size source_list = os.listdir(source) for item in source_list: source_path = os.path.join(source, os.path.basename(item)) if os.path.isfile(source_path): size += os.path.getsize(source_path) else: size += get_size(source_path) return sizeprint(get_size('a_a.py')) 移动文件夹 12345678910111213141516171819202122232425262728def move_dir(source, target): if not os.path.exists(source): print('不存在该文件，无法移动') return if os.path.abspath(source) == os.path.abspath(target): print('源文件地址与指定的地址相同，无法进行移动') return if os.path.isfile(source): source_fp = open(source, 'r') target_fp = open(target, 'w') content = source_fp.read(1024) while content: target_fp.write(content) content = source_fp.read(1024) source_fp.close() target_fp.close() os.remove(source) else: if not os.path.exists(target): os.makedirs(target) source_list = os.listdir(source) for item in source_list: source_item = os.path.join(source, item) target_item = os.path.join(target, item) move_dir(source_item, target_item) os.rmdir(source)move_dir('a', 'c') 目录整理 1234567891011121314151617181920212223242526# 将目录按后缀进行分类，后缀相同的放到后缀字母大写的文件中，没有后缀的放置在'OTHERS'中，文件夹放在'DIRS'中import os, shutildef clean_dir(source): if os.path.isfile(source) or not os.path.exists(source): print('当前目录无法整理，请查询你要整理的目录！') return source_list = os.listdir(source) for item in source_list: source_path = os.path.join(source, item) if os.path.isfile(source_path): suffix = source_path.rsplit('.', 1) if len(suffix) == 2: SUFFIX = os.path.join(source, suffix[1].upper()) if not SUFFIX: os.mkdir(SUFFIX) shutil.move(source_path, SUFFIX) else: OTHERS = os.path.join(source, 'OTHERS') if not OTHERS: os.mkdir(OTHERS) shutil.move(source_path, OTHERS) else: DIRS = os.path.join(source, 'DIR') if not DIRS: os.mkdir(DIRS) shutil.move(source_path, DIRS) 3.11. 时间、日期和日历相关模块函数 time模块： sleep：休眠指定的秒数(可以是小数) localtime： 将一个时间戳转换为time.struct_time类型的对象(类似于元组) 123import timeprint(time.localtime())&gt;&gt;&gt; time.struct_time(tm_year=2019, tm_mon=4, tm_mday=28, tm_hour=9, tm_min=25, tm_sec=34, tm_wday=6, tm_yday=118, tm_isdst=0) 年、月、日、时、分、秒、星期(0~6)、今年的第几天、夏令时 mktime：根据元组形式的时间生成一个时间的时间戳 123import timeprint(time.mktime((2019, 4, 28, 9, 25, 34, 6, 118, 0))) # 注意一定是一个元组&gt;&gt;&gt; 1556414734.0 strftime：将一个元组形式的时间格式化为字符串，不传时间默认转换当前时间 123time.strftime('%Y-%m-%d %H:%M:%S %w %W', local_time)&gt;&gt;&gt; '2019-04-28 09:34:53 0 16'# 注意与datetime.datetime.strftime的区别，datetime.datetime.strftime(time, '%Y-%m-%d %H:%M:%S:%f') gmtime：将一个时间戳转换为元组形式，不传默认转换当前时间 12print(time.gmtime())# time.struct_time(tm_year=2019, tm_mon=4, tm_mday=28, tm_hour=1, tm_min=50, tm_sec=27, tm_wday=6, tm_yday=118, tm_isdst=0) asctime：将一个元组形式的时间转换为标准格式字符串，不传参数转换当前时间 12print(time.asctime())# 'Sun Apr 28 09:49:13 2019' timezone：0时区减去当前时区的秒数 1print(time.timezone) # -28800 datetime模块： date()：获取一定格式的时间，print(date(2019, 5. 3)), # 2019-05-03 d = date.today()：获取今天的时间 d.fromtimestamp()：将时间戳转化为日期， print(d.fromtimestamp(time.time())) d.isoformat()：标准格式字符 d.isocalendar()：日历显示形式，如(年，第几周， 星期几) d.isoweekday()：获取星期(1~7) d.weekday(): 获取星期(0~6) d.strftime()：格式化，print(d.strftime(&#39;%y-%m-%d&#39;)) d.timetuple()：转化为元组 time()：获取一定格式的时间，tm = time() tm.hour：获取小时 tm.minute：获取分钟 tm.second：获取秒数 tm.strftime()：时间格式化，print(tm.strftime(&#39;%H:%M:%S&#39;)) datetime： datetime.now()：获取本地时间 datetime.utcnow()：获取UTC时间(格林尼治时间) datetime.fromtimestamp()：将一个时间戳转化为datetime datetime.fromtimestamp.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)：格式化显示 timedelta(): delta = timedelta()：获取时间差，print(timedelta(days=2, hours=2, seconds=56)) delta.days：获取天数 delta.seconds：获取天数外的秒数 delta.total_seconds()：获取总秒数 calendar模块： calendar：获取某一年的日历 12# 获取某一年的日历, 参数：年份， w =列宽， l= 行宽，m = 控制每行打印月份数， c=每个月份之间的间距c = calendar.calendar(2018, w=3, l=2, m=2, c=10) month：获取指定年指定月份的日历： 12# 获取指定年指定月的日历m = calendar.month(2018, 3) isleap：判断是否是闰年 1print(calendar.isleap(2062)) leapdays：判断两个年份之间的瑞年的个数([起始，结束)) 1print(calendar.leapdays(1992, 2018)) 3.12. 短信邮件相关模块函数 hashlib：用来进行hash或者md5加密，而且这种加密是不可逆的，所以这种算法又被称为摘要算法。其支持Openssl库提供的所有算法，包括md5、sha1、sha224、sha256、sha512等。 md5()：创建一个md5加密模式的hash对象，可以指定需要加密的字符串 update()：设置加密字符串，创建md5对象就不必指定了，不能两个地方都指定 hexdigest()：获取加密后的摘要(32位) 12345678import hashlibmd = hashlib.md5() md.update('123456'.encode('utf-8'))print(md.hexdigest()) # e10adc3949ba59abbe56e057f20f883emd = hashlib.md5('123456'.encode('utf-8')) # 如果添加参数，就相当于多进一层加密md.update('123456'.encode('utf-8'))print(md.hexdigest()) # ea48576f30be1669971699c09ad05c94 urlib：提供了一系列用于操作URL的功能，是Python的标准库 request：发送http请求 urlopen()：访问目标网址，结果是一个http.client.HTTPResponse对象，默认访问方法是GET，当在该方法中传入data参数时，则会发起POST请求。 1urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None) 123456789from urllib import requestrep = request.urlopen('http://www.baidu.com')print(rep.read().decode('utf-8'))# urlopen返回对象提供方法： # read() , readline() ,readlines() , fileno() , close() ：对HTTPResponse类型数据进行操作。 # info()：返回HTTPMessage对象，表示远程服务器返回的头信息。 # getcode()：返回Http状态码。 geturl()：返回请求的url。 1234from urllib import request# 设置timeout，如果请求时间超出，那么就会抛出异常resp = request.urlopen('http://httpbin.org', data='word=hello'.encode('utf-8'), timeout=10)print(resp.read().decode('utf-8')) Reuqest()：传入的request对象，而不是一个url 12345678urllib.request.Request(url, data=None, headers=&#123;&#125;, origin_req_host=None, unverifiable=False, method=None)url--访问的地址。data--此参数为可选字段，其中传递的参数需要转为bytes，如果是字典我们只需要通过urlencode转换即可。headers--http相应headers传递的信息，构造方法：headers参数传递，通过调用Request对象的add_header()方法来添加请求头。origin_req_host--指的是请求方的host名称或者IP地址。unverifiable--用来表明这个请求是否是无法验证的，默认是False。意思就是说用户没有足够权限来选择接收这个请求的结果。如果没有权限，这时unverifiable的值就是True 。method--用来指示请求使用的方法，比如GET，POST，PUT等 123456789101112131415161718192021# 使用urllib模拟微博登录from urllib import requestfrom urllib.parse import urlencodeprint('Login to weibo.cn...')email = input('Email: ')passwd = input('Password: ')login_data = urlencode([ ('username', email), ('password', passwd), ('entry', 'mweibo'), ('client_id', ''), ('savestate', '1'), ('ec', ''), ('pagerefer', 'https://passport.weibo.cn/signin/welcome?entry=mweibo&amp;r=http%3A%2F%2Fm.weibo.cn%2F')])req = request.Request('https://passport.weibo.cn/sso/login')req.add_header('Origin', 'https://passport.weibo.cn')req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')req.add_header('Referer', 'https://passport.weibo.cn/signin/login?entry=mweibo&amp;res=wel&amp;wm=3349&amp;r=http%3A%2F%2Fm.weibo.cn%2F')rep = request.urlopen(req, data=login_data.encode('utf-8'))print(rep.read().decode('utf-8')) 添加Cookie：使用request.build_opener方法来进行构造opener 12345678910111213from http import cookiejarfrom urllib import requesturl = 'http://httpbin.org/cookies'# 创建一个cookiejar对象cookie = cookiejar.CookieJar()# 使用HTTPCookieProcessor创建cookie处理器cookies = request.HTTPCookieProcessor(cookie)# 并以它为参数创建Opener对象opener = request.build_opener(cookies)# 使用这个opener来发起请求resp = opener.open(url)print(resp.read().decode()) 或者也可以把这个生成的opener使用install_opener方法来设置为全局的。则之后使用urlopen方法发起请求时，都会带上这个cookie。 123# 将这个opener设置为全局的openerrequest.install_opener(opener)resp = request.urlopen(url) 设置Proxy代理：使用爬虫来爬取数据的时候，常常需要使用代理来隐藏我们的真实IP。 12345678910from urllib import requesturl = 'http://httpbin.org/ip'proxy = &#123;'http':'50.233.137.33:80','https':'50.233.137.33:80'&#125;# 创建代理处理器proxies = requet.ProxyHandler(proxy)# 创建opener对象opener = request.build_opener(proxies)resp = opener.open(url)print(resp.read().decode()) error：处理请求过程中出现的异常 用 try-except来捕捉异常,主要的错误方式就两种URLError（错误信息）和HTTPError(错误编码)。 12345678from urllib import request, errortry: data= request.urlopen(url) print(data.read().decode('utf-8'))except error.HTTPError as e: # 错误编码 print(e.code)except error.URLError as e: # 错误信息 print(e.reason) parse：解析url urlencode()将字典转化为key1=value1&amp;key2=value2格式 123456from urllib.parse import urlencodedata = &#123; 'name': 'lajos', 'age': 18&#125;print(urlencode(data)) # name=lajos&amp;age=18 urlparse()：解析url中的所有参数，得到的是urllib.parse.ParseResult对象 parse_qs()：将url请求参数转化为字典 123456from urllib.parse import parse_qs, urlparseurl = 'http://www.baidu.com/abc/def?name=lajos&amp;age=18'url_parse = urlparse(url)print(url_parse) # ParseResult(scheme='http', netloc='www.baidu.com', path='/abc/def', params='', query='name=lajos&amp;age=18', fragment='')print(url_parse.query) # name=lajos&amp;age=18print(parse_qs(url_parse.query)) # &#123;'name': ['lajos'], 'age': ['18']&#125; robotparser：解析robots.txt文件 http.client：网络请求 12345678910import http.client# 创建连接(相当于浏览器)connect = http.client.HTTPConnection('www.baidu.com')# 发送请求(GET/POST)connect.request(method='GET', url='http://www.baidu.com')# 获取响应resp = connect.getresponse()# 打印响应内容，读取并解码print(resp.read().decode('utf-8')) 邮件发送smtplib：提供了一种很方便的途径发送电子邮件。它对smtp协议进行了简单的封装。 SMTP():（Simple Mail Transfer Protocol)即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。 12345import smtplibsmtp_obj = smtplib.SMTP([host, [, port [, local_hostname]]])# host: SMTP 服务器主机。 你可以指定主机的ip地址或者域名如: runoob.com，这个是可选参数。# port: 如果你提供了host参数, 你需要指定SMTP服务使用的端口号，一般情况下SMTP端口号为25。# local_hostname: 如果 SMTP 在你的本机上，你只需要指定服务器地址为 localhost 即可。 SMTP.sendmail()：发送邮件 1234SMTP.sendmail(from_addr, to_addrs, msg[, mail_options, rcpt_options])# from_addr: 邮件发送者地址。# to_addrs: 字符串列表，邮件发送地址。# msg: 发送消息，格式是字符串，一般包含标题，发信人，收件人，邮件内容，附件等 12345678910111213141516171819202122232425262728293031323334353637383940import smtplibfrom email.mime.text import MIMETextfrom email.header import Headerfrom email.mime.multipart import MIMEMultipartimport os# 邮箱服务器mail_server = 'smtp.qq.com'# 用户名mail_user = '13249732498@qq.com'# 密码或授权码，为了不公开可以通过环境变量的方式获取mail_password = os.environ.get('MAIL_PASSWORD') or '123456'# 邮件消息def send_mail(to_addrs): try: message = '你好，欢迎注册xxx平台，激活请点击右边链接 &lt;a href=\"http://www.baidu.com\"&gt;点击激活&lt;/a&gt;' # 将邮件字符串消息转换邮件格式，若内容是HTML需要指定第二个参数为'html' message = MIMEText(message, 'html') # 设置主题 message['Subject'] = Header('账户激活') # 设置显示的发件人 message['From'] = Header(mail_user) # 设置显示的收件人，可以给多个人发邮件 message['To'] = Header(to_addrs) # 创建邮件对象 mail = smtplib.SMTP(mail_server, 25) # 登录服务器 mail.login(mail_user, mail_password) # 发送邮件 mail.sendmail(mail_user, to_addrs, message.as_string()) mail.quit() except Exception: ret = False return retret = send_mail('1823423231@qq.com, 23423412@163.com')if ret: print('邮件发送成功！')else: print('邮件发送失败！') 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import smtplibfrom email.mime.text import MIMETextfrom email.header import Headerfrom email.mime.multipart import MIMEMultipartimport os# 邮箱服务器mail_server = 'smtp.qq.com'# 用户名mail_user = '1287174078@qq.com'# 密码或授权码，为了不公开可以通过环境变量的方式获取mail_password = os.environ.get('MAIL_PASSWORD') or 'qwewqrewr'# 邮件消息def send_mail(to_addrs): try: message = MIMEMultipart() # 设置主题 message['Subject'] = Header('账户激活') # 设置显示的发送人 message['From'] = Header(mail_user) # 设置显示的收件人，可以给多个人发邮件 message['To'] = Header(to_addrs) body = '这是Python邮件发送测试.....' # 邮件正文内容 message.attach(MIMEText(body, 'plain')) # 构造附件1，传送当前目录下的 test.txt 文件 att1 = MIMEText(open('test1.txt', 'rb').read(), 'base64', 'utf-8') att1['Content-Type'] = 'application/octet-stream' att1[\"Content-Disposition\"] = 'attachment; filename=\"test.txt\"' message.attach(att1) # 构造附件2，传送当前目录下的 runoob.txt 文件 att2 = MIMEText(open('yunda.py', 'rb').read(), 'base64', 'utf-8') att2[\"Content-Type\"] = 'application/octet-stream' att2[\"Content-Disposition\"] = 'attachment; filename=\"yunda.py\"' message.attach(att2) # 创建邮件对象 mail = smtplib.SMTP(mail_server, 25) # 登录服务器 mail.login(mail_user, mail_password) # 发送邮件 mail.sendmail(mail_user, to_addrs, message.as_string()) mail.quit() except Exception: ret = False return retret = send_mail('1825871201@qq.com')if ret: print('邮件发送成功！')else: print('邮件发送失败！') 短信发送：常使用短信发送平台，如阿里、云之讯、秒滴 该案例使用阿里短信平台对接，需要的参数如下： 安装Python环境的依赖包：pip install aliyun-python-sdk-core，使用于python2.6.5及其更高版本 accessKeyId：主账号AccessKey的IDaccessSecret：主账号的密钥SignName：短信签名名称PhoneNumbers：要发送的电话号码TemplateCode：短信模板ID，例如&#39;SMS_153055065&#39;TemplateParam：短信模板变量对应的实际值，JSON格式，如&#39;{&quot;code&quot;: &quot;1234&quot;}&#39; 1234567891011121314151617181920# 将对应的参数替换即可进行调用阿里云短信服务平台from aliyunsdkcore.client import AcsClientfrom aliyunsdkcore.request import CommonRequestclient = AcsClient('&lt;accessKeyId&gt;', '&lt;accessSecret&gt;', 'default')request = CommonRequest()request.set_accept_format('json')request.set_domain('dysmsapi.aliyuncs.com')request.set_method('POST')request.set_protocol_type('https') # https | httprequest.set_version('2017-05-25')request.set_action_name('SendSms')request.add_query_param('SignName', 'lajos')request.add_query_param('PhoneNumbers', '15299013421')request.add_query_param('TemplateCode', 'SMS_135695051')request.add_query_param('TemplateParam', '&#123;\"code\": \"1123\"&#125;')response = client.do_action(request)print(str(response, encoding='utf-8'))","link":"","tags":[{"name":"Python","slug":"Python","permalink":"https://lajos182.github.io/tags/Python/"},{"name":"函数","slug":"函数","permalink":"https://lajos182.github.io/tags/%E5%87%BD%E6%95%B0/"}]},{"title":"No.2 Python语言基础--变量、数据类型及运算符","date":"2020-04-27T07:09:51.000Z","path":"2020/04/27/No-2-Python语言基础-变量、数据类型及运算符/","text":"2.1. 标识符、变量与常量标识符：开发人员在程序中自定义的一些符合和名称，其实就是一串字符串，如变量名、函数名等 Python标识符规则：只能由数字、字符和下划线组成，开头不能是数字，不能是关键字，大小写敏感且见名知义，要遵循小驼峰原则。 123import keywordprint(keyword.kwlist) # 关键字列表&gt;&gt;&gt;['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 变量：在程序运行过程中，其值可以改变的量。 变量命名原则：尽量做到见名知意、尽量使用英文、推荐使用全小写加下划线的方式，如user_name 常量：程序运行期间不会改变的数据，如a = 1。在python中没有常量，通常使用大写字母加下划线的方式模拟，如：USER_NAME = &#39;xiaoming&#39; 代码注释：单行注释（# 注释内容）、多行注释（&#39;&#39;&#39;注释&#39;&#39;&#39;, &quot;&quot;&quot;注释&quot;&quot;&quot;） 2.2. 数据类型数据类型是为了处理不同的运算而存在，python中的数据类型有：整型(int)、浮点(float)、字符串(str)、列表(list)、元组(tuple)、字典(dict)、集合(set)、空(NoneType) 2.2.1. 字符串格式化在 Python 3.6 之前，字符串格式化方法主要有两种：%格式化 和 str.format()，Python3.6提供了一种新的字符串格式化方法：f-string (1)%-格式化从 Python 刚开始时就存在了，堪称「一届元老」，但是 Python 官方文档中并不推荐这种格式化方式： 这里描述的格式化操作容易表现出各种问题，导致许多常见错误（例如无法正确显示元组和字典）。 使用较新的格式化字符串文字或 str.format() 可以有助于避免这些错误。这些替代方案还提供了更强大，灵活和可扩展的格式化文本方法。 1234&gt;&gt;&gt; name = 'lajos'&gt;&gt;&gt; age = 18&gt;&gt;&gt; 'hello, %s, your age is %s ?' %(name, age)'hello, lajos, your age is 18?' (2)str.formar()从Python2.6开始引入，它使用普通函数调用语法，并且可以通过 __format__() 方法为对象进行扩展。 12&gt;&gt;&gt; \"hello, &#123;&#125;. you are &#123;&#125;?\".format(name,age)'hello, hoxis. you are 18?' 12&gt;&gt;&gt; \"hello, &#123;1&#125;. you are &#123;0&#125;?\".format(age,name)'hello, hoxis. you are 18?' 12&gt;&gt;&gt; \"hello, &#123;name&#125;. you are &#123;age1&#125;?\".format(age1=age,name=name)'hello, hoxis. you are 18?' 123&gt;&gt;&gt; person = &#123;\"name\":\"hoxis\",\"age\":18&#125;&gt;&gt;&gt; \"hello, &#123;name&#125;. you are &#123;age&#125;?\".format(**person)'hello, hoxis. you are 18?' (3)f-Strings是指以 f 或 F 开头的字符串，其中以 {} 包含的表达式会进行值替换。f-string 里的 f 也许可以代表 fast，它比 %格式化方法和 str.format() 都要快： 1234567891011121314151617181920212223242526272829303132333435363738394041&gt;&gt;&gt; name = 'hoxis'&gt;&gt;&gt; age = 18&gt;&gt;&gt; f\"hi, &#123;name&#125;, are you &#123;age&#125;\" # 替换字符串'hi, hoxis, are you 18'&gt;&gt;&gt; F\"hi, &#123;name&#125;, are you &#123;age&#125;\"'hi, hoxis, are you 18'&gt;&gt;&gt; f\"&#123;name.lower()&#125; is handsome.\" # 调用函数'hoxis is handsome.'&gt;&gt;&gt; class Person:... def __init__(self,name,age):... self.name = name... self.age = age... def __str__(self):... return f\"&#123;self.name&#125; is &#123;self.age&#125;\" # 在类中使用... def __repr__(self):... return f\"&#123;self.name&#125; is &#123;self.age&#125;. HAHA!\"...&gt;&gt;&gt; hoxis = Person(\"hoxis\",18)&gt;&gt;&gt; f\"&#123;hoxis&#125;\"'hoxis is 18'&gt;&gt;&gt; f\"&#123;hoxis!r&#125;\"'hoxis is 18. HAHA!'&gt;&gt;&gt; print(hoxis)hoxis is 18&gt;&gt;&gt; hoxishoxis is 18. HAHA!&gt;&gt;&gt; name = 'hoxis'&gt;&gt;&gt; age = 18&gt;&gt;&gt; status = 'Python'&gt;&gt;&gt; message = &#123;... f'hi &#123;name&#125;.'... f'you are &#123;age&#125;.'... f'you are learning &#123;status&#125;.'... &#125; # 多行f-string&gt;&gt;&gt;&gt;&gt;&gt; message&#123;'hi hoxis.you are 18.you are learning Python.'&#125; （4）f-string在python3.8中加入新特性，可以在表达式的末尾添加=,此时可以同时显示表达式和值 123&gt;&gt;&gt; python &#x3D; 3.8&gt;&gt;&gt; f&#39;&#123;python&#x3D;&#125;&#39;&#39;python &#x3D; 3.8&#39; 2.2.2. 列表、元组、字典、集合的区别 特点 列表 列表是一组任意类型的值，按照一定的顺序组合而成； 通过索引来标识元素，第一个索引为0；需要注意的是索引可以是负值； 3列表中元素是任意类型的，包括列表类型； 可以进行合并，删除，索引，切片等操作； 5 定义表使用中括号。 元组 元组是任意对象的有序集合（这一点和列表相同）；元组是不可变的（不能 增，删，改），但可以对元组进行合并；元组的速度比列表要快；定义元组使用小括号；需要注意的是定义一个元素时需要加上逗号，例如tuple=（333，）。 字典 字典是通过键值对进行存储的，所以字典没有顺序；字典是通过键值进行索引的且键值必须唯一； 字典可以进行增，删，改，查等操作，可以包含任意其他类型；定义字典使用大括号，各个键值对之间使用逗号隔开。 集合 集合是简单对象的无序不重复元素集合； 集合分为可变集合set（元素是可哈希的），不可变集合frozenset（元素不可哈希）；可以进行去除重复元素；可以进行并集，交集，差集等。 字典的创建方法： 直接创建：dict = {&#39;name&#39;: &#39;earth&#39;, &#39;port&#39;: 80} 1234567class dict(**kwarg) # **kwargs -- 关键字class dict(mapping, **kwarg) # mapping -- 元素的容器。class dict(iterable, **kwarg) # iterable -- 可迭代对象。dict1 = &#123;\"a\": 1, \"b\": 2&#125;dict2 = &#123;\"c\": 3&#125;dict3 = dict(dict1, **dict2) # dict3 = &#123;\"a\": 1, \"b\": 2, \"c\": 3&#125; 工厂方法： 123items = [('name', 'earth'), ('port', 80)]dict1 = dict(items)dict2 = dict((['name', 'earth'], ['port', '80'])) fromkeys()方法 12dict1 = &#123;&#125;.fromkeys(('x', 'y'), -1) # &#123;'x': -1, 'y': -1&#125;dict2 = &#123;&#125;.fromkeys(('x', 'y')) # &#123;'x': None, 'y': None&#125; 2.3. 运算符与流程控制2.3.1. 运算符 运算符优先级：无需记录运算符的优先级，需要的时候添加()即可。 灵活的or：a = False or 2， 赋值前会判断前面的值，若为真则使用，若为假，则使用or后面的值 海象表达式:=:python3.8引入的新语法，将给变量赋值，这个变量可以是表达式的一部分。 123456789101112# 用在if中可以避免调用len()两次if (n := len(a)) &gt; 10: print(f'List is too long (&#123;n&#125; elements, expected &lt;= 10)')# 正则表达式匹配和获取结果的时候discount = 0.00if (mo := re.search(r'(\\d+)% discount', advertisement)): discount = float(mo.group(1)) / 100.0# 用在while循环语句中，可以同时取值，并判断是否为空while (block := f.read(256) != ''): process(block) 2.3.2. 流程控制 列表生成式： 12345print([i for i in range(1, 11)])print([i*2 for i in range(1, 11)])print([i*i for i in range(1, 11)])print([str(i) for i in range(1, 11)])print([i for i in range(1, 11) if i % 2 == 0]) 冒泡排序法：每次比较相邻的两个元素，不合适就交换，依次向后，一圈下来可以确定一个元素；需要使用双重循环，外层循环控制循环的圈数， 内层控制一圈怎么交换 12345678910111213141516171819def bubble_sort(lt, key=None, reverse=False): for i in range(len(lt) - 1): for j in range(len(lt) - 1 - i): if key == None: temp = lt[i] &lt;= lt[i + 1] if reverse else lt[i] &gt; lt[i + 1] else: temp = key(lt[i]) &lt;= lt[i + 1] if reverse else key(lt[i]) &gt; key(lt[i + 1]) if temp: lt[i], lt[i + 1] = lt[i + 1], lt[i] print(lt) lt1 = [1, 5, 2, 1, 4, 9]lt2 = [ &#123;'name': 'xiaoming', 'age': 12, 'height': 160&#125;, &#123;'name': 'xiaohua', 'age': 17, 'height': 140&#125;, &#123;'name': 'xiaogang', 'age': 11, 'height': 180&#125;]choose_sort(lt1)choose_sort(lt2, key=lamamb x: x['age']) 选择排序法：每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 1234567891011121314151617181920def choose_sort(lt, key=None, reverse=False): for i in range(len(lt) - 1): for j in range(i + 1, len(lt)): if key == None: temp = lt[i] &lt;= lt[j] if reverse else lt[i] &gt; lt [j] else: temp = key(lt[i]) &lt;= key(lt[j]) if reverse else key(lt[i]) &gt; key(lt[j]) if temp: lt[i], lt[j] = lt[j], lt[i] print(lt) lt1 = [1, 5, 2, 1, 4, 9]lt2 = [ &#123;'name': 'xiaoming', 'age': 12, 'height': 160&#125;, &#123;'name': 'xiaohua', 'age': 17, 'height': 140&#125;, &#123;'name': 'xiaogang', 'age': 11, 'height': 180&#125;]choose_sort(lt1)choose_sort(lt2, key=lamamb x: x['age'])","link":"","tags":[{"name":"Python","slug":"Python","permalink":"https://lajos182.github.io/tags/Python/"}]},{"title":"No.1 Python简介与版本介绍","date":"2020-04-27T04:08:33.000Z","path":"2020/04/27/No-1-Python简介与版本介绍/","text":"1.1. Python简介 Python是一种解释型(不需要编译)、面向对象、动态数据类型的交互式语言，Python是由由荷兰人Guido van Rossum于1989年发明，第一个公开发行版发行于1991年。 Python的优势： 易于学习：Python有相对较少的关键字，结构简单，有明确定义的语法，学习起来相对简单。 易于阅读：Python代码的定义比较清晰，易于阅读。 易于维护：Python的成功在于它的源代码是相当容易维护。 具有一个广泛的标准库：Python的最大优势之一是具有丰富的库，可跨平台，兼容性较好。 互动模式：互动模式的支持，您可以从终端输入执行代码并获得结果的语言，互动的测试和调试代码的片段。 可移植：基于其开放源代码的特性，Python已经被移植到许多平台。 可扩展性：如果需要一段运行很快的关键代码，或者想要编程一些不愿开放的算法，你可以使用c或者c++完成那部分程序，然后从你的Python程序中进行调用。 GUI编程：Python支持GUI可以创建和移植到许多系统调用。 可嵌入：你可以将Python嵌入到c/c++程序中，让你的程序用户得到“脚本”的能力。 缺点： 运行速度慢：和C程序相比比较慢，因为Python是解释型语言，代码在执行时会一行一行的编译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。 代码不能加密：如果要发布Python程序，实际上就是发布源代码，这一点与C语言不同,C语言不能发布源代码，只需要把编译后的机器码（也就是windows上常见的xxx.exe文件）发布出去。要从机器码反推出C代码是不可能的，所以，凡是编译型的语言，都没有这个问题，而解释型的语言，则必 1.2. Python的设计模式设计模式的定义：为了解决面向对象系统中重要和重复的设计封装在一起的一种代码实现框架,可以使得代码更加易于扩展和调用。 设计模式的基本要素：模式名称、问题、解决方案、效果。 设计模式的六大原则： 开闭原则：一个软件实体,如类,模块和函数应该对扩展开发,对修改关闭.既软件实体应尽量在不修改原有代码的情况下进行扩展。 里氏替换原则：所有引用父类的方法必须能透明的使用其子类的对象。 依赖倒置原则：高层模块不应该依赖底层模块,二者都应该依赖其抽象,抽象不应该依赖于细节,细节应该依赖抽象,换而言之,要针对接口编程而不是针对实现编程。 接口隔离原则：使用多个专门的接口,而不是使用单一的总接口,即客户端不应该依赖那些并不需要的接口。 迪米特法则：一个软件实体应该尽可能的少与其他实体相互作用。 单一职责原则：不要存在多个导致类变更的原因.即一个类只负责一项职责。 Python的设计模式： 二十三设计模式案例详情，可参考：https://www.cnblogs.com/Liqiongyu/p/5916710.html 1.3. 单例模式 单利模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。 1&#96;__new__()&#96;在&#96;__init__()&#96;之前被调用，用于生成实例对象。利用这个方法和类的属性的特点可以实现设计模式的单例模式。单例模式是指创建唯一对象，单例模式设计的类只能实例 **这个绝对常考啊.绝对要记住1~2个方法,当时面试官是让手写的.** 1.3.1. 使用__new__方法__new__是真正创建实例对象的方法，所以重写基类的__new__方法，以此来保证创建对象的时候只生成一个实例 12345678910111213class Singleton(object): _instance = None def __new__(cls, *args, **kwargs): if cls._instance == super(Singlento, cls).__new__(cls, *args, **kwargs) return cls._instanceclass Foo(Signleton): passfoo1 = Foo()foo2 = Foo()print(foo1 is foo2) # True 1.3.2. 使用装饰器装饰器维护一个字典对象instances，缓存了所有单例类，只要单例不存在则创建，已经存在直接返回该实例对象。 12345678910111213141516def singleton(cls): instances = &#123;&#125; def wrapper(*args, **kwargs): if cls not in instances: instances[cls] = cls(*args, **kwargs) return instance[cls] return wrapper@singletonclass Foo(object): passfoo1 = Foo()foo2 = Foo()print(foo1 is foo2) # True 1.3.3. 使用元类元类（参考：深刻理解Python中的元类）是用于创建类对象的类，类对象创建实例对象时一定会调用__call__方法，因此在调用__call__时候保证始终只创建一个实例即可，type是python中的一个元类。 123456789101112131415class Singleton(type): def __call__(cls, *args, **kwargs): if not hasattr(cls, '_instance'): cls._instance = super(Singleton, cls).__call__(*args, **kwargs) return cls._instance class Foo(object): __metaclass__ = Singleton foo1 = Foo()foo2 = Foo() print(foo1 is foo2) # True 1.3.4. import方法import作为python的模块，是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。如果我们真的想要一个单例类，可以考虑这样做： 12345class My_Singleton(object): def foo(self): pass my_singleton = My_Singleton() 将上面的代码保存在文件 mysingleton.py 中，然后这样使用： 123from mysingleton import my_singleton my_singleton.foo() 单例模式伯乐在线详细解释 1.4. Python中的元类(metaclass)这个非常的不常用,但是像ORM这种复杂的结构还是会需要的,详情请看:http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python，中文看这个解释很详细深刻理解Python中的元类 Python处处皆对象，类其实也是对象，使用class关键字时，Python会自动创建此对象。但与Python中的大多数内容一样，type为您提供了手动执行此操作的方法。type有一个完全不同的能力，它也可以动态创建类。type可以将类的描述作为参数，并返回一个类。 123456789type(类名, 类名的元组(针对继承的情况，可以为空), 包含属性的字典(名称和值))&gt;&gt;&gt; Foo = type('Foo', (), &#123;'bar': True&#125;)&gt;&gt;&gt; print(Foo)True&gt;&gt;&gt; f = Foo()&gt;&gt;&gt; print(f)&lt;__main__.Foo object at 0x8a9b84c&gt;&gt;&gt;&gt; print(f.bar)True 1.5. Python自省这个也是python彪悍的特性. 自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type()，dir()，getattr()，hasattr()，isinstance() 1.5.1. 访问对象的属性dir([obj])：调用这个方法将返回包含obj大多数属性名的列表（会有一些特殊的属性不包含在内）。obj的默认值是当前的模块对象。 hasattr(obj, attr)：这个方法用于检查obj是否有一个名为attr的值的属性，返回一个布尔值。 getattr(obj, attr)：调用这个方法将返回obj中名为attr值的属性的值，例如如果attr为’bar’，则返回obj.bar。 setattr(obj, attr, val)：调用这个方法将给obj的名为attr的值的属性赋值为val。例如如果attr为’bar’，则相当于obj.bar = val。 123456789101112131415161718class Cat(object): def __init__(self, name, *args, **kwargs): self.name = name def sayHi(self): print(self.name)cat = Cat('kitty')print(cat.name)cat.sayHi()print(dir(cat)) # 获取实例的属性名，以列表形式返回&gt;&gt;&gt; ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'name', 'sayHi']if hasattr(cat, 'name'): # 检查实例是否有这个属性 setattr(cat, 'name', 'tiger') # same as: a.name = 'tiger'print(getattr(cat, 'name')) # same as: print(a.name)getattr(cat, 'sayHi')() # same as: cat.sayHi() 1.5.2. insepect模块自省is{module|class|function|method|builtin}(obj)：检查对象是否为模块、类、函数、方法、内建函数或方法。 isroutine(obj)：用于检查对象是否为函数、方法、内建函数或方法等等可调用类型。用这个方法会比多个is()更方便，不过它的实现仍然是用了多个is()。 getmembers(object[, predicate])：这个方法是dir()的扩展版，它会将dir()找到的名字对应的属性一并返回，形如[(name, value), …]。另外，predicate是一个方法的引用，如果指定，则应当接受value作为参数并返回一个布尔值，如果为False，相应的属性将不会返回。使用is*作为第二个参数可以过滤出指定类型的属性。 getmodule(object)：返回object的定义所在的模块对象。 get{file|sourcefile}(object)：获取object的定义所在的模块的文件名|源代码文件名（如果没有则返回None）。用于内建的对象（内建模块、类、函数、方法）上时会抛出TypeError异常。 get{source|sourcelines}(object)：获取object的定义的源代码，以字符串|字符串列表返回。代码无法访问时会抛出IOError异常。只能用于module/class/function/method/code/frame/traceack对象。 getargspec(func)：仅用于方法，获取方法声明的参数，返回元组，分别是(普通参数名的列表, 参数名, *参数名, 默认值元组)。如果没有值，将是空列表和3个None。如果是2.6以上版本，将返回一个命名元组(Named Tuple)，即除了索引外还可以使用属性名访问元组中的元素。 getargvalues(frame)：仅用于栈帧，获取栈帧中保存的该次函数调用的参数值，返回元组，分别是(普通参数名的列表, 参数名, *参数名, 帧的locals())。如果是2.6以上版本，将返回一个命名元组(Named Tuple)，即除了索引外还可以使用属性名访问元组中的元素。 getcallargs(func[, *args][, **kwds])：返回使用args和kwds调用该方法时各参数对应的值的字典。这个方法仅在2.7版本中才有。 getmro(cls)：返回一个类型元组，查找类属性时按照这个元组中的顺序。如果是新式类，与cls.__mro__结果一样。但旧式类没有__mro__这个属性，直接使用这个属性会报异常，所以这个方法还是有它的价值的。 currentframe()：返回当前的栈帧对象。 1.6. Python中的重载引自知乎:http://www.zhihu.com/question/20053359 函数重载的目的：解决可变参数类型、可变参数个数两大问题。 另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。 函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。 函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是缺省参数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。 1.7. 新式类和旧式类stackoverflow 在Python 2.1中，旧式类是用户可用的唯一风格。 （旧式）类的概念与类型的概念无关：如果x是旧式类的实例，则x.__class__ 指定类的类x，但type(x)始终是&lt;type &#39;instance&#39;&gt;。 这反映了这样一个事实，即所有旧式实例独立于其类，都使用一个称为实例的内置类型实现。 Python 2.2中引入了新式类，以统一类和类型的概念。新式类只是用户定义的类型，不多也不少。 如果x是新样式类的实例，那么type(x)通常是相同的x.__class__（尽管不能保证 - 允许新样式类实例覆盖返回的值x.__class__）。 引入新式类的主要动机是提供具有完整元模型的统一对象模型。 它还具有许多直接的好处，例如能够对大多数内置类型进行子类化，或引入“描述符”，从而启用计算属性。 出于兼容性原因，默认情况下类仍为旧式。 通过将另一个新样式类（即类型）指定为父类来创建新样式类，或者如果不需要其他父类，则创建“顶级类型”对象。 除了返回的类型之外，新样式类的行为在许多重要细节中与旧样式类的行为不同。 其中一些更改是新对象模型的基础，就像调用特殊方法的方式一样。其他是针对兼容性问题之前无法实现的“修复”，例如在多重继承的情况下的方法解析顺序。 Python 3只有新式的类。 无论你是否是子类object，类都是Python 3中的新风格。这篇文章很好的介绍了新式类的特性: http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html 一个旧式类的深度优先的例子 123456789101112131415161718class A(): def foo1(self): print('A')class B(A): def foo2(self): pass class C(A): def foo1(self): print('C') class D(B, C): passd = D()d.foo1()&gt;&gt;&gt; C 按照经典类的查找顺序从左到右深度优先的规则，在访问d.foo1()的时候,D这个类是没有的..那么往上查找,先找到B,里面没有,深度优先,访问A,找到了foo1(),所以这时候调用的是A的foo1()，从而导致C重写的foo1()被绕过。但在新式类种，按照广度优先的原则，访问d.foo1()时，D没有，继续找B，发现B里面也没有foo1()，再找C， C中有foo1()，直接就调用该方法，输入结果就是C。 1.8. 鸭子模型Python崇尚鸭子类型，即‘如果看起来像、叫声像而且走起路来像鸭子，那么它就是鸭子 python程序员通常根据这种行为来编写程序。例如，如果想编写现有对象的自定义版本，可以继承该对象。 也可以创建一个外观和行为像，但与它无任何关系的全新对象，后者通常用于保存程序组件的松耦合度。 1.9. Python中的作用域Python中，程序的变量并不是哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python的作用域一共有4种，分别是： L（Local） 局部作用域 E（Enclosing）闭包函数外的函数中 G（Global）全局作用域 B（Bulit-in）内置作用域（内置函数所在模块的范围） Python执行时查找作用域的顺序是L-E-G-B，即：先在局部找，局部找不到去局部外的局部(闭包)，然后是全局再到内建 12345g_count = 0 # 全局作用域def outer(): o_count = 1 # 闭包函数外的函数中 def inner(): i_count = 2 # 局部作用域 1.10. GIL线程全局锁线程全局锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制,说白了就是一个核只能在同一时间运行一个线程.对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。 见Python 最难的问题 解决办法就是多进程和下面的协程(协程也只是单CPU,但是能减小切换代价提升性能). 1.11. Python里的拷贝1.12. Python垃圾回收机制Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。 1.12.1. 引用计数PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少.引用计数为0时，该对象生命就结束了。 优点: 简单 实时性 缺点: 维护引用计数消耗资源 循环引用 1.12.2. 标记-清除机制基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。 1.12.3. 分代技术分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。 Python默认定义了三代对象集合，索引数越大，对象存活时间越长。 举例： 当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。 1.13. Python2.x与Python3.x区别Python2.x与Python3.x区别","link":"","tags":[{"name":"Python","slug":"Python","permalink":"https://lajos182.github.io/tags/Python/"}]}]